<!DOCTYPE HTML>
<html lang="en">

<head>
    <style>
        body,
        html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100%;
        }

        canvas {
            display: block;
        }
    </style>
    <title> Super Earth </title>
    <meta charset="utf-8">
    <script src="glMatrix.js"></script>
    <script src="webgl-debug.js"></script>
    <!--Texture Shaders-->
    <script id="shader-vs" type="x-shader/x-vertex">
        attribute vec3 aVertexPosition;   // Vertex position
    attribute vec3 aVertexNormal;     // Vertex normal
    attribute vec2 aTextureCoord;     // Texture coordinates

    uniform mat4 uMVMatrix;           // Model-View matrix
    uniform mat4 uPMatrix;            // Projection matrix
    uniform mat3 uNMatrix;            // Normal matrix

    varying vec3 vTransformedNormal;  // Transformed normal
    varying vec3 vPositionEye;        // Position in eye coordinates
    varying vec2 vTextureCoord;       // Texture coordinates

    void main(void) {
        // Transform the vertex position into eye coordinates
        vec4 positionEye = uMVMatrix * vec4(aVertexPosition, 1.0);
        vPositionEye = positionEye.xyz;

        // Pass the transformed normal
        vTransformedNormal = uNMatrix * aVertexNormal;

        // Pass the texture coordinates
        vTextureCoord = aTextureCoord;

        // Calculate the final position
        gl_Position = uPMatrix * positionEye;
    }


    </script>
    <script id="shader-fs" type="x-shader/x-fragment">
        precision mediump float;

uniform sampler2D uSampler;
uniform vec3 uLightDirection;
uniform vec3 uLightColor;
uniform vec3 uAmbientLightColor;
uniform vec3 uSpecularColor;

varying vec3 vTransformedNormal;
varying vec3 vPositionEye;
varying vec2 vTextureCoord;

void main(void) {
    // Normalize the normal and light direction
    vec3 normal = normalize(vTransformedNormal);
    vec3 lightDir = normalize(-uLightDirection);

    // Ambient lighting
    vec3 ambient = uAmbientLightColor;

    // Diffuse lighting (Lambertian reflectance)
    float diffuseFactor = max(dot(normal, lightDir), 0.0);
    vec3 diffuse = uLightColor * diffuseFactor;

    // Specular lighting (Phong reflectance)
    vec3 viewDir = normalize(-vPositionEye);
    vec3 reflectionDir = reflect(-lightDir, normal);
    float specFactor = pow(max(dot(viewDir, reflectionDir), 0.0), 16.0);
    vec3 specular = uSpecularColor * specFactor;

    // Combine lighting components
    vec3 lighting = ambient + diffuse + specular;

    // Use a solid color if texture is unavailable
    vec4 solidColor = vec4(1.0, 1.0, 1.0, 1.0); // Default white
    vec4 texelColor = texture2D(uSampler, vTextureCoord);
    if (texelColor.a == 0.0) { // Use solid color when texture is missing
        gl_FragColor = vec4(solidColor.rgb * lighting, solidColor.a);
    } else {
        gl_FragColor = vec4(texelColor.rgb * lighting, texelColor.a);
    }
}

    </script>
    <!-- Golden Shaders -->
    <script id="golden-vs" type="x-shader/x-vertex">
        attribute vec3 aVertexPosition;
attribute vec3 aVertexNormal;

uniform mat4 uMVMatrix;   // Model-View matrix
uniform mat4 uPMatrix;    // Projection matrix
uniform mat3 uNMatrix;    // Normal matrix

varying vec3 vTransformedNormal; // Transformed normal vector
varying vec3 vPositionEye;       // Position in eye coordinates

void main(void) {
    // Transform the vertex position to eye coordinates
    vec4 positionEye = uMVMatrix * vec4(aVertexPosition, 1.0);
    vPositionEye = positionEye.xyz;

    // Transform and normalize the normal vector
    vTransformedNormal = normalize(uNMatrix * aVertexNormal);

    // Final position in clip space
    gl_Position = uPMatrix * positionEye;
}

</script>

    <script id="golden-fs" type="x-shader/x-fragment">
        precision mediump float;

varying vec3 vTransformedNormal; // Normal vector in eye coordinates
varying vec3 vPositionEye;       // Vertex position in eye coordinates

uniform vec3 uLightDirection;    // Direction of the light source
uniform vec3 uLightColor;        // Light color

const vec3 ambientColor = vec3(0.3, 0.2, 0.1);  // Ambient "golden" tone
const vec3 goldColor = vec3(1.0, 0.843, 0.0);   // Base golden color
const vec3 specularColor = vec3(1.0, 1.0, 1.0); // Specular highlight color

void main(void) {
    // Normalize the normal and light direction
    vec3 normal = normalize(vTransformedNormal);
    vec3 lightDir = normalize(-uLightDirection);

    // Compute the view direction
    vec3 viewDir = normalize(-vPositionEye);

    // Ambient lighting
    vec3 ambient = ambientColor;

    // Diffuse lighting
    float diffuseFactor = max(dot(normal, lightDir), 0.0);
    vec3 diffuse = goldColor * diffuseFactor;

    // Specular lighting (Phong reflection model)
    vec3 reflectionDir = reflect(-lightDir, normal);
    float specFactor = pow(max(dot(viewDir, reflectionDir), 0.0), 16.0); // Shininess = 16
    vec3 specular = specularColor * specFactor;

    // Combine all components
    vec3 lighting = ambient + diffuse + specular;

    // Final color output
    gl_FragColor = vec4(lighting, 1.0);
}

        
        
</script>
    <script type="text/javascript">

        let gl;
        let canvas;
        let shaderProgram;
        let goldenShaderProgram;
        let sphereVertexPositionBuffer;
        let sphereIndexPositionBuffer;
        let modelViewMatrix;
        let projectionMatrix;
        let modelViewMatrixStack;
        let satelliteAngle = 0;
        let panelVertexPositionBuffer;
        let panelIndexBuffer;
        let elapsedTime = 0;
        let lastTime = 0;

        let satelliteOrbitRadius = 50; // Distance from Earth"s center
        let satelliteOrbitSpeed = 0.001;
        let satelliteOrbitAngle = 0;

        let zoomValue = 100;
        let moveX = 0;
        let moveY = 0;

        let rotateX = 0;
        let rotateY = 0;

        let isPanning = false;

        function createGLContext(canvas) {
            let names = ["webgl", "experimental-webgl"];
            let context = null;
            for (let i = 0; i < names.length; i++) {
                try {
                    context = canvas.getContext(names[i]);
                } catch (e) { }
                if (context) {
                    break;
                }
            }
            if (context) {
                context.viewportWidth = canvas.width;
                context.viewportHeight = canvas.height;
            } else {
                alert("Failed to create WebGL context!");
            }
            return context;
        }
        function loadShaderFromDOM(id) {
            let shaderScript = document.getElementById(id);
            if (!shaderScript) {
                return null;
            }
            let shaderSource = "";
            let currentChild = shaderScript.firstChild;
            while (currentChild) {
                if (currentChild.nodeType == 3) { // 3 corresponds to TEXT_NODE
                    shaderSource += currentChild.textContent;
                }
                currentChild = currentChild.nextSibling;
            }
            let shader;
            if (shaderScript.type == "x-shader/x-fragment") {
                shader = gl.createShader(gl.FRAGMENT_SHADER);
            } else if (shaderScript.type == "x-shader/x-vertex") {
                shader = gl.createShader(gl.VERTEX_SHADER);
            } else {
                return null;
            }
            gl.shaderSource(shader, shaderSource);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                alert(gl.getShaderInfoLog(shader));
                return null;
            }
            return shader;
        }
        function setupShaders() {
            let vertexShader = loadShaderFromDOM("shader-vs");
            let fragmentShader = loadShaderFromDOM("shader-fs");
            shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);
            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                alert("Failed to setup shaders");
            }
            gl.useProgram(shaderProgram);

            shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
            console.log("aVertexPosition Location:", shaderProgram.vertexPositionAttribute);

            shaderProgram.vertexNormalAttribute = gl.getAttribLocation(shaderProgram, "aVertexNormal");
            console.log("aVertexNormal Location:", shaderProgram.vertexNormalAttribute);

            shaderProgram.vertexTextureCoordAttribute = gl.getAttribLocation(shaderProgram, "aTextureCoord");
            console.log("aTextureCoord Location:", shaderProgram.vertexTextureCoordAttribute);

            shaderProgram.uLightDirection = gl.getUniformLocation(shaderProgram, "uLightDirection");
            shaderProgram.uLightColor = gl.getUniformLocation(shaderProgram, "uLightColor");
            shaderProgram.uAmbientLightColor = gl.getUniformLocation(shaderProgram, "uAmbientLightColor");
            shaderProgram.uSpecularColor = gl.getUniformLocation(shaderProgram, "uSpecularColor");


            shaderProgram.uniformMVMatrix = gl.getUniformLocation(shaderProgram, "uMVMatrix");
            shaderProgram.uniformProjMatrix = gl.getUniformLocation(shaderProgram, "uPMatrix");
            shaderProgram.uLightPosition = gl.getUniformLocation(shaderProgram, "uLightPosition");
            shaderProgram.uAmbientLightColor = gl.getUniformLocation(shaderProgram, "uAmbientLightColor");
            shaderProgram.uDiffuseLightColor = gl.getUniformLocation(shaderProgram, "uDiffuseLightColor");
            shaderProgram.uSpecularLightColor = gl.getUniformLocation(shaderProgram, "uSpecularLightColor");
            shaderProgram.uNMatrix = gl.getUniformLocation(shaderProgram, "uNMatrix");


            shaderProgram.samplerUniform = gl.getUniformLocation(shaderProgram, "uSampler");
            // Initialise the matrices
            modelViewMatrix = mat4.create();
            projectionMatrix = mat4.create();
            modelViewMatrixStack = [];
            gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);

            shaderProgram.uLightDirection = gl.getUniformLocation(shaderProgram, "uLightDirection");
            shaderProgram.uLightColor = gl.getUniformLocation(shaderProgram, "uLightColor");

            console.log("uLightDirection Location:", shaderProgram.uLightDirection);
            console.log("uLightColor Location:", shaderProgram.uLightColor);
        }

        function setupGoldenShader() {
            let goldenVertexShader = loadShaderFromDOM("golden-vs");
            let goldenFragmentShader = loadShaderFromDOM("golden-fs");
            goldenShaderProgram = gl.createProgram();

            gl.attachShader(goldenShaderProgram, goldenVertexShader);
            gl.attachShader(goldenShaderProgram, goldenFragmentShader);
            gl.linkProgram(goldenShaderProgram);

            if (!gl.getProgramParameter(goldenShaderProgram, gl.LINK_STATUS)) {
                alert("Failed to setup golden shaders");
            }

            // Get attribute locations
            goldenShaderProgram.vertexPositionAttribute = gl.getAttribLocation(goldenShaderProgram, "aVertexPosition");
            gl.enableVertexAttribArray(goldenShaderProgram.vertexPositionAttribute);

            goldenShaderProgram.vertexNormalAttribute = gl.getAttribLocation(goldenShaderProgram, "aVertexNormal");
            gl.enableVertexAttribArray(goldenShaderProgram.vertexNormalAttribute);

            // Get uniform locations
            goldenShaderProgram.uMVMatrix = gl.getUniformLocation(goldenShaderProgram, "uMVMatrix");
            goldenShaderProgram.uPMatrix = gl.getUniformLocation(goldenShaderProgram, "uPMatrix");
            goldenShaderProgram.uNMatrix = gl.getUniformLocation(goldenShaderProgram, "uNMatrix");
            goldenShaderProgram.uLightDirection = gl.getUniformLocation(goldenShaderProgram, "uLightDirection");
            goldenShaderProgram.uLightColor = gl.getUniformLocation(goldenShaderProgram, "uLightColor");

            console.log("Golden Shader Attributes and Uniforms Setup Complete");
        }



        function setLightingUniforms() {
            // Directly use a normalized light direction vector
            let lightDirection = [-5, -5, 0];
            let lightColor = [1, 1, 1];
            let ambientLightColor = [0.4, 0.4, 0.4];
            let specularColor = [0.5, 0.5, 0.5];

            // Pass light uniforms to the shader
            gl.uniform3fv(shaderProgram.uLightDirection, lightDirection);
            gl.uniform3fv(shaderProgram.uLightColor, lightColor);
            gl.uniform3fv(shaderProgram.uAmbientLightColor, ambientLightColor);
            gl.uniform3fv(shaderProgram.uSpecularColor, specularColor);
        }







        function pushModelViewMatrix() {
            let copyToPush = mat4.create(modelViewMatrix);
            modelViewMatrixStack.push(copyToPush);
        }
        function popModelViewMatrix() {
            if (modelViewMatrixStack.length == 0) {
                throw "Error popModelViewMatrix() - Stack was empty ";
            }
            modelViewMatrix = modelViewMatrixStack.pop();
        }

        function setupSphereBuffers(radius) {
            // Using gl.Triangles (drawElements) to draw a sphere
            sphereVertexPositionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, sphereVertexPositionBuffer);
            let sphereVertexPosition = [];
            let r = radius;
            let m = 15;
            let n = 15;

            for (let i = 0; i <= m; i++) {
                for (let j = 0; j <= n; j++) {
                    // Calculate x, y, and z
                    let theta = (i * Math.PI) / m;         // Latitude angle
                    let phi = (2 * j * Math.PI) / n;      // Longitude angle
                    let x = r * Math.sin(theta) * Math.cos(phi);
                    let y = r * Math.cos(theta);
                    let z = r * Math.sin(theta) * Math.sin(phi);
                    sphereVertexPosition.push(x, y, z);
                }
            }

            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(sphereVertexPosition), gl.STATIC_DRAW);
            sphereVertexPositionBuffer.itemSize = 3;
            sphereVertexPositionBuffer.numberOfItems = (m + 1) * (n + 1);

            // Add texture coordinates
            sphereTextureCoordBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, sphereTextureCoordBuffer);
            let sphereTextureCoords = [];
            for (let i = 0; i <= m; i++) {
                for (let j = 0; j <= n; j++) {
                    let u = j / n; // Horizontal texture coordinate
                    let v = i / m; // Vertical texture coordinate
                    sphereTextureCoords.push(u, v);
                }
            }

            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(sphereTextureCoords), gl.STATIC_DRAW);
            sphereTextureCoordBuffer.itemSize = 2;
            sphereTextureCoordBuffer.numberOfItems = (m + 1) * (n + 1);

            // Set up indices for drawing elements
            sphereIndexPositionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, sphereIndexPositionBuffer);
            let sphereIndexPosition = [];
            for (let i = 0; i < m; i++) {
                for (let j = 0; j < n; j++) {
                    let v1 = i * (n + 1) + j;
                    let v2 = v1 + n + 1;
                    let v3 = v1 + 1;
                    let v4 = v2 + 1;

                    sphereIndexPosition.push(v1, v2, v3);
                    sphereIndexPosition.push(v3, v2, v4);
                }
            }

            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(sphereIndexPosition), gl.STATIC_DRAW);
            sphereIndexPositionBuffer.itemSize = 3;
            sphereIndexPositionBuffer.numberOfItems = m * n * 2 * 3;

            // Add normals for lighting calculations
            let sphereNormalData = []; // Array to hold the sphere normals

            for (let i = 0; i < sphereVertexPosition.length; i += 3) {
                let x = sphereVertexPosition[i];
                let y = sphereVertexPosition[i + 1];
                let z = sphereVertexPosition[i + 2];

                // Normalize the vertex position to calculate the normal
                let length = Math.sqrt(x * x + y * y + z * z);
                sphereNormalData.push(x / length, y / length, z / length);
            }


            sphereNormalBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, sphereNormalBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(sphereNormalData), gl.STATIC_DRAW);
            sphereNormalBuffer.itemSize = 3;
            sphereNormalBuffer.numItems = sphereNormalData.length / 3;

        }

        function setupCubeBuffers() {
            // Vertex positions for a cube (centered at origin)
            cubeVertexPositionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);

            const cubeVertexPosition = [
                // Front face
                3.0, 3.0, 3.0, -3.0, 3.0, 3.0, -3.0, -3.0, 3.0, 3.0, -3.0, 3.0,
                // Back face
                3.0, 3.0, -3.0, -3.0, 3.0, -3.0, -3.0, -3.0, -3.0, 3.0, -3.0, -3.0,
                // Top face
                3.0, 3.0, -3.0, 3.0, 3.0, 3.0, -3.0, 3.0, 3.0, -3.0, 3.0, -3.0,
                // Bottom face
                3.0, -3.0, -3.0, 3.0, -3.0, 3.0, -3.0, -3.0, 3.0, -3.0, -3.0, -3.0,
                // Right face
                3.0, 3.0, -3.0, 3.0, 3.0, 3.0, 3.0, -3.0, 3.0, 3.0, -3.0, -3.0,
                // Left face
                -3.0, 3.0, -3.0, -3.0, 3.0, 3.0, -3.0, -3.0, 3.0, -3.0, -3.0, -3.0
            ];

            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(cubeVertexPosition), gl.STATIC_DRAW);
            cubeVertexPositionBuffer.itemSize = 3;
            cubeVertexPositionBuffer.numberOfItems = 24;

            // Normals for each face of the cube
            cubeNormalBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, cubeNormalBuffer);

            const cubeNormals = [
                // Front face normals
                0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0,
                // Back face normals
                0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0,
                // Top face normals
                0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0,
                // Bottom face normals
                0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0,
                // Right face normals
                1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0,
                // Left face normals
                -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0
            ];

            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(cubeNormals), gl.STATIC_DRAW);
            cubeNormalBuffer.itemSize = 3;
            cubeNormalBuffer.numberOfItems = 24;

            // Indices for the cube (two triangles per face, 6 faces total)
            cubeVertexIndexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);

            const cubeVertexIndices = [
                0, 1, 2, 0, 2, 3,    // Front face
                4, 6, 5, 4, 7, 6,    // Back face
                8, 9, 10, 8, 10, 11,  // Top face
                12, 14, 13, 12, 15, 14, // Bottom face
                16, 17, 18, 16, 18, 19, // Right face
                20, 22, 21, 20, 23, 22  // Left face
            ];

            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cubeVertexIndices), gl.STATIC_DRAW);
            cubeVertexIndexBuffer.itemSize = 1;
            cubeVertexIndexBuffer.numberOfItems = 36;
        }


        function setupCylinderBuffers() {
            cylinderVertexPositionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, cylinderVertexPositionBuffer);

            let radius = 0.1;
            let height = 1.5;
            let numSegments = 36;
            let cylinderVertices = [];
            let cylinderNormals = [];
            let angleStep = (2 * Math.PI) / numSegments;

            // Generate vertices and normals for the sides of the cylinder
            for (let i = 0; i <= numSegments; i++) {
                let angle = i * angleStep;
                let x = Math.cos(angle) * radius;
                let z = Math.sin(angle) * radius;

                // Bottom circle
                cylinderVertices.push(x, -height / 2, z);
                cylinderNormals.push(x, 0, z); // Normal points outward

                // Top circle
                cylinderVertices.push(x, height / 2, z);
                cylinderNormals.push(x, 0, z); // Normal points outward
            }

            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(cylinderVertices), gl.STATIC_DRAW);
            cylinderVertexPositionBuffer.itemSize = 3;
            cylinderVertexPositionBuffer.numberOfItems = (numSegments + 1) * 2;

            // Generate normals buffer
            cylinderNormalBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, cylinderNormalBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(cylinderNormals), gl.STATIC_DRAW);
            cylinderNormalBuffer.itemSize = 3;
            cylinderNormalBuffer.numberOfItems = (numSegments + 1) * 2;

            // Generate indices for the sides
            cylinderIndexPositionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cylinderIndexPositionBuffer);
            let cylinderIndices = [];

            for (let i = 0; i < numSegments; i++) {
                let p1 = i * 2;
                let p2 = p1 + 1;
                let p3 = (i + 1) * 2;
                let p4 = p3 + 1;

                cylinderIndices.push(p1, p2, p3); // Triangle 1
                cylinderIndices.push(p3, p2, p4); // Triangle 2
            }

            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cylinderIndices), gl.STATIC_DRAW);
            cylinderIndexPositionBuffer.itemSize = 3;
            cylinderIndexPositionBuffer.numberOfItems = cylinderIndices.length;
        }


        function setupPanelBuffers() {
            panelVertexPositionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, panelVertexPositionBuffer);

            const width = 2.0;   // Half the width
            const height = 8.0;  // Half the height
            const depth = 0.2;   // Thickness

            // Define vertices for all 6 faces of the rectangular prism
            let panelVertexPosition = [
                // Front face
                width, height, depth, -width, height, depth, -width, -height, depth, width, -height, depth,
                // Back face
                width, height, -depth, -width, height, -depth, -width, -height, -depth, width, -height, -depth,
                // Top face
                width, height, -depth, width, height, depth, -width, height, depth, -width, height, -depth,
                // Bottom face
                width, -height, -depth, width, -height, depth, -width, -height, depth, -width, -height, -depth,
                // Right face
                width, height, -depth, width, -height, -depth, width, -height, depth, width, height, depth,
                // Left face
                -width, height, -depth, -width, -height, -depth, -width, -height, depth, -width, height, depth
            ];

            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(panelVertexPosition), gl.STATIC_DRAW);
            panelVertexPositionBuffer.itemSize = 3;
            panelVertexPositionBuffer.numberOfItems = 24;

            // Define normals for each face (flat shading)
            panelNormalBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, panelNormalBuffer);

            let panelNormals = [
                // Front face
                0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0,
                // Back face
                0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0,
                // Top face
                0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0,
                // Bottom face
                0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0,
                // Right face
                1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0,
                // Left face
                -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0
            ];

            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(panelNormals), gl.STATIC_DRAW);
            panelNormalBuffer.itemSize = 3;
            panelNormalBuffer.numberOfItems = 24;

            // Define indices for all 6 faces
            panelIndexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, panelIndexBuffer);

            const panelIndices = [
                0, 1, 2, 0, 2, 3,   // Front face
                4, 6, 5, 4, 7, 6,   // Back face
                8, 9, 10, 8, 10, 11, // Top face
                12, 14, 13, 12, 15, 14, // Bottom face
                16, 17, 18, 16, 18, 19, // Right face
                20, 22, 21, 20, 23, 22  // Left face
            ];

            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(panelIndices), gl.STATIC_DRAW);
            panelIndexBuffer.itemSize = 1;
            panelIndexBuffer.numberOfItems = 36;

            // Texture coordinates (apply texture to all 6 faces)
            panelTextureCoordBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, panelTextureCoordBuffer);

            let panelTextureCoords = [
                // Front face
                1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0,
                // Back face
                1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0,
                // Top face
                1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0,
                // Bottom face
                1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0,
                // Right face
                1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0,
                // Left face
                1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0
            ];

            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(panelTextureCoords), gl.STATIC_DRAW);
            panelTextureCoordBuffer.itemSize = 2;
            panelTextureCoordBuffer.numberOfItems = 24;
        }





        function setupDishBuffers() {
            dishVertexPositionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, dishVertexPositionBuffer);

            let radius = 2;
            let numRings = 20;
            let numSegments = 36;
            let curvature = 0.5;
            let dishVertices = [];
            let angleStep = (2 * Math.PI) / numSegments;

            // Generate dish vertices
            for (let ring = 0; ring <= numRings; ring++) {
                let r = (ring / numRings) * radius; // Radius at this ring
                let z = -curvature * (1 - (ring / numRings)) ** 2; // Curved depth on z-axis

                for (let segment = 0; segment <= numSegments; segment++) {
                    let angle = segment * angleStep;
                    let x = r * Math.cos(angle); // x position
                    let y = r * Math.sin(angle); // y position

                    dishVertices.push(x, y, z);
                }
            }

            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(dishVertices), gl.STATIC_DRAW);
            dishVertexPositionBuffer.itemSize = 3;
            dishVertexPositionBuffer.numberOfItems = (numRings + 1) * (numSegments + 1);

            // Generate indices
            dishIndexPositionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, dishIndexPositionBuffer);

            let dishIndices = [];

            for (let ring = 0; ring < numRings; ring++) {
                for (let segment = 0; segment < numSegments; segment++) {
                    let p1 = ring * (numSegments + 1) + segment;
                    let p2 = p1 + numSegments + 1;
                    let p3 = p1 + 1;
                    let p4 = p2 + 1;

                    dishIndices.push(p1, p2, p3); // Triangle 1
                    dishIndices.push(p3, p2, p4); // Triangle 2
                }
            }

            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(dishIndices), gl.STATIC_DRAW);
            dishIndexPositionBuffer.itemSize = 1;
            dishIndexPositionBuffer.numberOfItems = dishIndices.length;
        }

        function setupBuffers() {
            setupSphereBuffers(30);
            setupCubeBuffers();

            setupCylinderBuffers(0.1);
            setupCylinderBuffers(0.2);

            setupPanelBuffers();

            setupDishBuffers();
        }

        function uploadModelViewMatrixToShader() {
            gl.uniformMatrix4fv(shaderProgram.uniformMVMatrix, false, modelViewMatrix);

            // Calculate and send the normal matrix
            let normalMatrix = mat3.create();
            mat4.toInverseMat3(modelViewMatrix, normalMatrix);
            mat3.transpose(normalMatrix, normalMatrix);

            gl.uniformMatrix3fv(shaderProgram.uNMatrix, false, normalMatrix);
        }
        function uploadProjectionMatrixToShader() {
            gl.uniformMatrix4fv(shaderProgram.uniformProjMatrix, false, projectionMatrix);
        }

        function calculateNormalMatrix() {
            let normalMatrix = mat3.create();
            mat4.toInverseMat3(modelViewMatrix, normalMatrix);
            mat3.transpose(normalMatrix, normalMatrix);
            return normalMatrix;
        }


        let solarPanelTexture;
        let earthTexture;

        function setupTextures() {
            solarPanelTexture = gl.createTexture();
            solarPanelImage = new Image();
            solarPanelImage.onload = function () {
                console.log("solar panel texture loaded!!!!!!!");
                gl.bindTexture(gl.TEXTURE_2D, solarPanelTexture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, solarPanelImage);

                // Texture parameters
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

                gl.bindTexture(gl.TEXTURE_2D, null);
            };
            solarPanelImage.src = "solarPanel.jpg";

            earthTexture = gl.createTexture();
            earthTexture.image = new Image();
            earthTexture.image.onload = function () {
                console.log("earth texture loaded!1");
                handleTextureLoaded(earthTexture);
            }
            earthTexture.image.src = "earth.jpg";

        }

        function handleTextureLoaded(texture) {
            gl.bindTexture(gl.TEXTURE_2D, texture);

            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true); // Flip the texture Y-axis

            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.image);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
            gl.generateMipmap(gl.TEXTURE_2D);
            gl.bindTexture(gl.TEXTURE_2D, null);
        }

        function drawSphere() {
            gl.useProgram(shaderProgram);

            // Bind position buffer
            gl.bindBuffer(gl.ARRAY_BUFFER, sphereVertexPositionBuffer);
            gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);

            // Bind normal buffer
            gl.bindBuffer(gl.ARRAY_BUFFER, sphereNormalBuffer);
            gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(shaderProgram.vertexNormalAttribute);

            // Bind texture buffer
            gl.bindBuffer(gl.ARRAY_BUFFER, sphereTextureCoordBuffer);
            gl.vertexAttribPointer(shaderProgram.vertexTextureCoordAttribute, 2, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(shaderProgram.vertexTextureCoordAttribute);

            // Bind Earth texture
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, earthTexture);
            gl.uniform1i(shaderProgram.samplerUniform, 0);

            // Draw the sphere
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, sphereIndexPositionBuffer);
            gl.drawElements(gl.TRIANGLES, sphereIndexPositionBuffer.numberOfItems, gl.UNSIGNED_SHORT, 0);
        }




        function drawCube() {
            gl.useProgram(goldenShaderProgram);

            // Pass model-view and projection matrices
            gl.uniformMatrix4fv(goldenShaderProgram.uMVMatrix, false, modelViewMatrix);
            gl.uniformMatrix4fv(goldenShaderProgram.uPMatrix, false, projectionMatrix);

            // Pass the normal matrix (inverse transpose of model-view)
            let normalMatrix = mat3.create();
            mat4.toInverseMat3(modelViewMatrix, normalMatrix);
            mat3.transpose(normalMatrix, normalMatrix);
            gl.uniformMatrix3fv(goldenShaderProgram.uNMatrix, false, normalMatrix);

            // Pass light direction
            let lightDirection = [-5.0, -5.0, -5.0];
            gl.uniform3fv(goldenShaderProgram.uLightDirection, lightDirection);
            gl.uniform3fv(goldenShaderProgram.uLightColor, [1.0, 1.0, 1.0]); // White light

            // Bind vertex position buffer
            gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
            gl.vertexAttribPointer(
                goldenShaderProgram.vertexPositionAttribute,
                cubeVertexPositionBuffer.itemSize,
                gl.FLOAT, false, 0, 0
            );
            gl.enableVertexAttribArray(goldenShaderProgram.vertexPositionAttribute);

            // Bind normal buffer (ensure normals are defined in `setupCubeBuffers`)
            gl.bindBuffer(gl.ARRAY_BUFFER, cubeNormalBuffer);
            gl.vertexAttribPointer(
                goldenShaderProgram.vertexNormalAttribute,
                3, gl.FLOAT, false, 0, 0
            );
            gl.enableVertexAttribArray(goldenShaderProgram.vertexNormalAttribute);

            // Bind index buffer
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);

            // Draw the cube
            gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numberOfItems, gl.UNSIGNED_SHORT, 0);

            // Reset program
            gl.useProgram(shaderProgram);
        }






        function drawCylinder(r, g, b, a) {
            // Set a solid color as a uniform

            gl.vertexAttrib4f(shaderProgram.vertexColorAttribute, r, g, b, a);

            // Bind the vertex position buffer
            gl.bindBuffer(gl.ARRAY_BUFFER, cylinderVertexPositionBuffer);
            gl.vertexAttribPointer(
                shaderProgram.vertexPositionAttribute,
                cylinderVertexPositionBuffer.itemSize,
                gl.FLOAT, false, 0, 0
            );
            gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);

            // Bind the normals buffer
            gl.bindBuffer(gl.ARRAY_BUFFER, cylinderNormalBuffer);
            gl.vertexAttribPointer(
                shaderProgram.vertexNormalAttribute,
                cylinderNormalBuffer.itemSize,
                gl.FLOAT, false, 0, 0
            );
            gl.enableVertexAttribArray(shaderProgram.vertexNormalAttribute);

            // Upload matrices
            uploadModelViewMatrixToShader();
            uploadProjectionMatrixToShader();

            // Draw the cylinder
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cylinderIndexPositionBuffer);
            gl.drawElements(gl.TRIANGLES, cylinderIndexPositionBuffer.numberOfItems, gl.UNSIGNED_SHORT, 0);
        }


        function drawPanel() {
            gl.useProgram(shaderProgram);

            // Bind vertex position buffer
            gl.bindBuffer(gl.ARRAY_BUFFER, panelVertexPositionBuffer);
            gl.vertexAttribPointer(
                shaderProgram.vertexPositionAttribute,
                panelVertexPositionBuffer.itemSize,
                gl.FLOAT, false, 0, 0
            );
            gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);

            // Bind normal buffer
            gl.bindBuffer(gl.ARRAY_BUFFER, panelNormalBuffer);
            gl.vertexAttribPointer(
                shaderProgram.vertexNormalAttribute,
                panelNormalBuffer.itemSize,
                gl.FLOAT, false, 0, 0
            );
            gl.enableVertexAttribArray(shaderProgram.vertexNormalAttribute);

            // Bind texture coordinates
            gl.bindBuffer(gl.ARRAY_BUFFER, panelTextureCoordBuffer);
            gl.vertexAttribPointer(
                shaderProgram.vertexTextureCoordAttribute,
                panelTextureCoordBuffer.itemSize,
                gl.FLOAT, false, 0, 0
            );
            gl.enableVertexAttribArray(shaderProgram.vertexTextureCoordAttribute);

            // Bind texture
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, solarPanelTexture);
            gl.uniform1i(shaderProgram.samplerUniform, 0);

            // Draw the panel
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, panelIndexBuffer);
            gl.drawElements(gl.TRIANGLES, panelIndexBuffer.numberOfItems, gl.UNSIGNED_SHORT, 0);
        }


        function drawDish(r, g, b, a) {
            gl.vertexAttrib4f(shaderProgram.vertexColorAttribute, r, g, b, a);

            gl.bindBuffer(gl.ARRAY_BUFFER, dishVertexPositionBuffer);
            gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, dishVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, dishIndexPositionBuffer);
            gl.drawElements(gl.TRIANGLES, dishIndexPositionBuffer.numberOfItems, gl.UNSIGNED_SHORT, 0);
        }

        function drawSatellite(orbitRadius) {
            satelliteOrbitRadius = orbitRadius; // Distance from Earth"s center

            pushModelViewMatrix();

            const satelliteX = satelliteOrbitRadius * Math.cos(satelliteOrbitAngle);
            const satelliteZ = satelliteOrbitRadius * Math.sin(satelliteOrbitAngle);

            mat4.translate(modelViewMatrix, [satelliteX, 0, satelliteZ]);

            mat4.rotateY(modelViewMatrix, -satelliteOrbitAngle);

            uploadModelViewMatrixToShader();
            drawCube(1.0, 1.0, 0.0, 1.0);


            pushModelViewMatrix();
            mat4.translate(modelViewMatrix, [0, 0, -3.5]); // Position left cylinder
            mat4.rotateZ(modelViewMatrix, Math.PI / 2);
            mat4.rotateX(modelViewMatrix, Math.PI / 2);
            uploadModelViewMatrixToShader();
            drawCylinder(0.0, 1.0, 0.0, 1.0);

            pushModelViewMatrix();
            mat4.translate(modelViewMatrix, [0, -8.8, 0]); // Move to cylinder"s end
            mat4.rotateY(modelViewMatrix, Math.PI / 2);
            uploadModelViewMatrixToShader();
            drawPanel();

            popModelViewMatrix();
            popModelViewMatrix();

            pushModelViewMatrix();
            mat4.translate(modelViewMatrix, [0, 0, 3.5]); // Position left cylinder
            mat4.rotateZ(modelViewMatrix, Math.PI / 2);
            mat4.rotateX(modelViewMatrix, Math.PI / 2);
            uploadModelViewMatrixToShader();
            drawCylinder(0.0, 0.0, 1.0, 1.0);

            pushModelViewMatrix();
            mat4.translate(modelViewMatrix, [0, 8.8, 0]); // Move to cylinder"s end
            mat4.rotateY(modelViewMatrix, Math.PI / 2);
            uploadModelViewMatrixToShader();
            drawPanel();

            popModelViewMatrix();
            popModelViewMatrix();

            pushModelViewMatrix();
            mat4.translate(modelViewMatrix, [-3.5, 0, 0]);
            mat4.rotateZ(modelViewMatrix, Math.PI / 2);
            uploadModelViewMatrixToShader();
            drawCylinder(0.0, 1.0, 1.0, 1.0);

            pushModelViewMatrix();
            mat4.translate(modelViewMatrix, [0, 1.2, 0]);
            mat4.rotateX(modelViewMatrix, Math.PI / -2);
            uploadModelViewMatrixToShader();
            drawDish(1.0, 1.0, 1.0, 1.0);

            popModelViewMatrix();
            popModelViewMatrix();

        }

        function drawEarth() {
            let angle = elapsedTime * 0.0005;
            pushModelViewMatrix();
            mat4.rotateY(modelViewMatrix, angle);
            mat4.rotateX(modelViewMatrix, 60);
            uploadModelViewMatrixToShader();
            drawSphere();
            popModelViewMatrix();
        }

        function drawScene(zoomValue, rotateX, rotateY, moveX, moveY) {
            gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            mat4.perspective(60, gl.viewportWidth / gl.viewportHeight, 0.1, 500.0, projectionMatrix);
            mat4.identity(modelViewMatrix);
            mat4.lookAt([rotateX, rotateY, zoomValue], [moveX, moveY, 0], [0, 1, 0], modelViewMatrix);
            setLightingUniforms();
            uploadProjectionMatrixToShader();
            uploadModelViewMatrixToShader();

            drawEarth();
            drawSatellite(satelliteOrbitRadius);
        }

        function handleUserControls() {
            document.addEventListener("keydown", function (event) {
                if (event.key === "ArrowRight") {
                    satelliteOrbitRadius += 1;
                    console.log("moving further from earth");
                } else if (event.key === "ArrowLeft") {
                    if (satelliteOrbitRadius > 40) {
                        satelliteOrbitRadius -= 1;
                        console.log("moving closer to earth");
                    } else {
                        console.log("TOO CLOSE BRUH!!!!!!!!!!!!!!!!!!!");
                    }
                }
            });

            document.addEventListener("keydown", function (event) {
                if (event.key === "ArrowUp") {
                    satelliteOrbitSpeed += 0.001;
                    console.log("speedup!!!!!!!!!1");
                } else if (event.key === "ArrowDown") {
                    if (satelliteOrbitSpeed > 0.001) {
                        satelliteOrbitSpeed -= 0.001;
                        console.log("slowdown!!");
                    } else {
                        console.log("slow down limit reached, do u want to crash to the earth? :>");
                    }
                }
            });

            document.addEventListener("wheel", function (event) {
                if (event.deltaY > 0) {
                    zoomValue += 5;
                    console.log("user holding down shift and scrolling up");
                } else if (event.deltaY < 0) {
                    zoomValue -= 5;
                    console.log("user holding down shift and scrolling down");
                }
            });


            document.addEventListener("mousedown", function (event) {
                if (event.shiftKey) {
                    let startX = event.clientX;
                    let lastX = startX;
                    document.addEventListener("mousemove", onMouseMove);

                    function onMouseMove(event) {
                        if (event.clientX < lastX) {
                            moveX -= 5;
                            console.log("user holding down shift and dragging left");
                        } else if (event.clientX > lastX) {
                            moveX += 5;
                            console.log("user holding down shift and dragging right");
                        }
                        lastX = event.clientX;
                    }
                }
                else if (event.altKey) {
                    let startY = event.clientY;
                    let lastY = startY;
                    document.addEventListener("mousemove", onMouseMove);

                    function onMouseMove(event) {
                        if (event.clientY < lastY) {
                            moveY += 5;
                            console.log("user alt dragging up");
                        } else if (event.clientY > lastY) {
                            moveY -= 5;
                            console.log("user alt dragging down");
                        }
                        lastY = event.clientY;
                    }
                } else {
                    let startY = event.clientY;
                    let lastY = startY;
                    let startX = event.clientX;
                    let lastX = startX;

                    document.addEventListener("mousemove", onMouseMove);

                    function onMouseMove(event) {
                        if (event.clientY < lastY) {
                            if (rotateY < 200) {
                                rotateY += 5;
                                console.log("user JUST dragging up", rotateY);
                            } else {
                                console.log("TOO HIGH BRUH!!!!!!!!!!!!!!!!!!!");
                            }
                        } else if (event.clientY > lastY) {
                            if (rotateY > -200) {
                                rotateY -= 5;
                                console.log("user JUST dragging down", rotateY);
                            } else {
                                console.log("TOO LOW BRUH!!!!!!!!!!!!!!!!!!!");
                            }
                        }
                        lastY = event.clientY;

                        if (event.clientX < lastX) {
                            if (rotateX > -200) {
                                rotateX -= 5;
                                console.log("user JUST dragging left", rotateX);
                            } else {
                                console.log("TOO LEFT BRUH!!!!!!!!!!!!!!!!!!!");
                            }
                        } else if (event.clientX > lastX) {
                            if (rotateX < 200) {
                                rotateX += 5;
                                console.log("user JUST dragging right", rotateX);
                            } else {
                                console.log("TOO RIGHT BRUH!!!!!!!!!!!!!!!!!!!");
                            }
                        }
                        lastX = event.clientX;
                    }
                }
                document.addEventListener("mouseup", function () {
                    document.removeEventListener("mousemove", onMouseMove);
                }, { once: true });
            });
        }

        function animate() {
            let timeNow = new Date().getTime();
            if (lastTime != 0) {
                let elapsed = timeNow - lastTime;
                elapsedTime += elapsed;
                satelliteOrbitAngle += elapsed * satelliteOrbitSpeed; // Update satellite angle
            }
            lastTime = timeNow;
        }

        function tick() {
            requestAnimationFrame(tick);
            drawScene(zoomValue, rotateX, rotateY, moveX, moveY);
            //animate();
        }

        function startup() {
            canvas = document.getElementById("myGLCanvas");
            gl = createGLContext(canvas);
            setupBuffers();
            setupShaders();
            setupTextures();
            setupGoldenShader();
            handleUserControls();
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.enable(gl.DEPTH_TEST);
            tick();
        }
    </script>
</head>

<body onload="startup();">
    <canvas id="myGLCanvas" width="1920" height="1000"></canvas>

</body>

</html>