<!DOCTYPE HTML>
<html lang="en">
<head>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100%;
        }
        canvas {
            display: block;
        }
    </style>
<title> Sphere </title>
<meta charset="utf-8">
<script src="glMatrix.js"></script>
<script src="webgl-debug.js"></script>
<script id="shader-vs" type=    "x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec4 aVertexColor;
    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;
    varying vec4 vColor;
    void main() {
    gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
    vColor = aVertexColor;
    }
</script>
<script id="shader-fs" type="x-shader/x-fragment">
    precision mediump float;
    varying vec4 vColor;
    void main() {
    gl_FragColor = vColor;
    }
</script>
<script type="text/javascript">
var gl;
var canvas;
var shaderProgram;
var sphereVertexPositionBuffer;
var sphereIndexPositionBuffer;
var modelViewMatrix;
var projectionMatrix;
var modelViewMatrixStack;
var satelliteAngle = 0; 
var panelVertexPositionBuffer;
var panelIndexBuffer;


function createGLContext(canvas) {
    var names = ["webgl", "experimental-webgl"];
    var context = null;
    for (var i=0; i < names.length; i++) {
        try {
        context = canvas.getContext(names[i]);
    } catch(e) {}
    if (context) {
        break;
    }
    }
    if (context) {
        context.viewportWidth = canvas.width;
        context.viewportHeight = canvas.height;
    } else {
        alert("Failed to create WebGL context!");
    }
    return context;
}
function loadShaderFromDOM(id) {
    var shaderScript = document.getElementById(id);
    if (!shaderScript) {
        return null;
    }
    var shaderSource = "";
    var currentChild = shaderScript.firstChild;
    while (currentChild) {
        if (currentChild.nodeType == 3) { // 3 corresponds to TEXT_NODE
            shaderSource += currentChild.textContent;
        }
        currentChild = currentChild.nextSibling;
    }
    var shader;
    if (shaderScript.type == "x-shader/x-fragment") {
        shader = gl.createShader(gl.FRAGMENT_SHADER);
    } else if (shaderScript.type == "x-shader/x-vertex") {
        shader = gl.createShader(gl.VERTEX_SHADER);
    } else {
        return null;
    }
    gl.shaderSource(shader, shaderSource);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        alert(gl.getShaderInfoLog(shader));
        return null;
    }
    return shader;
}
function setupShaders() {
    var vertexShader = loadShaderFromDOM("shader-vs");
    var fragmentShader = loadShaderFromDOM("shader-fs");
    shaderProgram = gl.createProgram();
    gl.attachShader(shaderProgram, vertexShader);
    gl.attachShader(shaderProgram, fragmentShader);
    gl.linkProgram(shaderProgram);
    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
        alert("Failed to setup shaders");
    }
    gl.useProgram(shaderProgram);
    shaderProgram.vertexPositionAttribute =
    gl.getAttribLocation(shaderProgram, "aVertexPosition");
    shaderProgram.vertexColorAttribute = gl.getAttribLocation(shaderProgram, "aVertexColor");
    shaderProgram.uniformMVMatrix =
    gl.getUniformLocation(shaderProgram, "uMVMatrix");
    shaderProgram.uniformProjMatrix =
    gl.getUniformLocation(shaderProgram, "uPMatrix");
    // Initialise the matrices
    modelViewMatrix = mat4.create();
    projectionMatrix = mat4.create();
    modelViewMatrixStack = [];
    gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);
}
function pushModelViewMatrix() {
    var copyToPush = mat4.create(modelViewMatrix);
    modelViewMatrixStack.push(copyToPush);
}
function popModelViewMatrix() {
    if (modelViewMatrixStack.length == 0) {
        throw "Error popModelViewMatrix() - Stack was empty ";
    }
    modelViewMatrix = modelViewMatrixStack.pop();
}
function setupEarthBuffers(){
    //using gl.Triangles (drawElements) to draw a sphere
    sphereVertexPositionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, sphereVertexPositionBuffer);
    var sphereVertexPosition=[];
    var r = 3 // radius
    //choosing an arbitrary value for m and n
    var m=15;
    var n=15;
    // calculate the vertex coordinates
    for (var i=0; i <= m; i++) {
        for (var j=0; j <=n; j++){
            //calculate x, y and z here
            //x=r*(Math.sin(theta))*(Math.cos(phi));
            x=r*Math.sin(i*Math.PI/m) * Math.cos(2*j*Math.PI/n)
            //y=(r*(Math.cos(theta)));
            y=r*Math.cos(i*Math.PI/m);
            //z=(r*(Math.sin(theta))*(Math.sin(phi)));
            z=r*Math.sin(i*Math.PI/m)*Math.sin(2*j*Math.PI/n);
            sphereVertexPosition.push(x);
            sphereVertexPosition.push(y);
            sphereVertexPosition.push(z);
        }
    }
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(sphereVertexPosition),
    gl.STATIC_DRAW);
    sphereVertexPositionBuffer.itemSize = 3;
    sphereVertexPositionBuffer.numberOfItems = (m+1)*(n+1);
    sphereIndexPositionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, sphereIndexPositionBuffer);
    //generate the indices of the triangle
    var sphereIndexPosition=[];
    for (var i=0; i < m; i ++){
        for (var j=0; j < n; j++){
            var v1 = i*(n+1) + j;
            var v2 = v1+n+1;
            var v3 = v1+1;
            var v4 = v2 + 1;
            //triangle 1
            sphereIndexPosition.push(v1);
            sphereIndexPosition.push(v2);
            sphereIndexPosition.push(v3);
            //triangle 2
            sphereIndexPosition.push(v3);
            sphereIndexPosition.push(v2);
            sphereIndexPosition.push(v4);
        }
    }
    //console.log(sphereIndexPosition);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new
    Uint16Array(sphereIndexPosition),
    gl.STATIC_DRAW);
    sphereIndexPositionBuffer.itemSize = 3;
    sphereIndexPositionBuffer.numberOfItems = m*n*2*3;
    //calculate vertex normals
    var sphereNormalData = [];
    for (var i=0; i <=m; i++){
        for (var j=0; j<=n; j++){
            //nx=Math.sin(theta)*Math.cos(theta);
            nx=(Math.sin((i*Math.PI)/m))*(Math.cos((2*j*Math.PI)/n));
            //ny=Math.cos(theta);
            ny=(Math.cos((i*Math.PI)/m));
            //nz=Math.sin(theta)*Math.sin(phi);
            nz=(Math.sin((i*Math.PI)/m))*(Math.sin((2*j*Math.PI)/n));
            sphereNormalData.push(nx);
            sphereNormalData.push(ny);
            sphereNormalData.push(nz);
        }
    }
    //console.log(sphereNormalData);
}
function setupCubeBuffers() {
    cubeVertexPositionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
    var cubeVertexPosition = [
    1.0, 1.0, 1.0, //v0
    -1.0, 1.0, 1.0, //v1
    -1.0, -1.0, 1.0, //v2
    1.0, -1.0, 1.0, //v3
    1.0, 1.0, -1.0, //v4
    -1.0, 1.0, -1.0, //v5
    -1.0, -1.0, -1.0, //v6
    1.0, -1.0, -1.0, //v7
    ];
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(cubeVertexPosition),
    gl.STATIC_DRAW);
    cubeVertexPositionBuffer.itemSize = 3;
    cubeVertexPositionBuffer.numberOfItems = 8;
    cubeVertexIndexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);

    //For simplicity, each face will be drawn as gl_TRIANGLES, therefore
    //the indices for each triangle are specified.
    var cubeVertexIndices = [
    0, 1, 2, 0, 2, 3, // Front face
    4, 6, 5, 4, 7, 6, // Back face
    1, 5, 6, 1, 6, 2, //left
    0, 3, 7, 0, 7, 4, //right
    0, 5, 1, 0, 4, 5, //top
    3, 2, 6, 3, 6, 7 //bottom
    ];
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cubeVertexIndices),
    gl.STATIC_DRAW);
    cubeVertexIndexBuffer.itemSize = 1;
    cubeVertexIndexBuffer.numberOfItems = 36;
}

function setupCylinderBuffers() {
    cylinderVertexPositionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, cylinderVertexPositionBuffer);
    
    var radius = 0.1;
    var height = 1.5;
    var numSegments = 36;
    var cylinderVertices = [];
    var angleStep = (2 * Math.PI) / numSegments;

    // Generate the cylinder vertices
    for (let i = 0; i <= numSegments; i++) {
        let angle = i * angleStep;
        let x = Math.cos(angle) * radius;
        let z = Math.sin(angle) * radius;

        // Bottom circle
        cylinderVertices.push(x, -height / 2, z);

        // Top circle
        cylinderVertices.push(x, height / 2, z);
    }

    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(cylinderVertices), gl.STATIC_DRAW);
    cylinderVertexPositionBuffer.itemSize = 3;
    cylinderVertexPositionBuffer.numberOfItems = (numSegments + 1) * 2;

    // Generate indices
    cylinderIndexPositionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cylinderIndexPositionBuffer);
    var cylinderIndices = [];

    for (let i = 0; i < numSegments; i++) {
        // Side triangles
        let p1 = i * 2;
        let p2 = p1 + 1;
        let p3 = (i + 1) * 2;
        let p4 = p3 + 1;

        cylinderIndices.push(p1, p2, p3);
        cylinderIndices.push(p3, p2, p4);
    }

    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cylinderIndices), gl.STATIC_DRAW);
    cylinderIndexPositionBuffer.itemSize = 3;
    cylinderIndexPositionBuffer.numberOfItems = cylinderIndices.length;
}


function setupPanelBuffers() {
    panelVertexPositionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, panelVertexPositionBuffer);

    // Define vertices for a 2D rectangle in the X-Y plane
    var panelVertexPosition = [
        0.2, 2.0, 0.0,  // v0 (top-right)
        -0.2, 2.0, 0.0, // v1 (top-left)
        -0.2, -2.0, 0.0, // v2 (bottom-left)
        0.2, -2.0, 0.0   // v3 (bottom-right)
    ];

    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(panelVertexPosition), gl.STATIC_DRAW);
    panelVertexPositionBuffer.itemSize = 3;
    panelVertexPositionBuffer.numberOfItems = 4;

    panelIndexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, panelIndexBuffer);

    // Define indices for two triangles to form the rectangle
    const panelIndices = [
        0, 1, 2, // Triangle 1
        0, 2, 3  // Triangle 2
    ];

    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(panelIndices), gl.STATIC_DRAW);
    panelIndexBuffer.itemSize = 1;
    panelIndexBuffer.numberOfItems = 6;
}

function setupBuffers() {
    setupEarthBuffers();
    setupCubeBuffers();

    // Set up cylinder buffers with different radii
    setupCylinderBuffers(0.1); // Default cylinder radius
    setupCylinderBuffers(0.2); // Larger cylinder radius

    setupPanelBuffers();
}

function uploadModelViewMatrixToShader() {
    gl.uniformMatrix4fv(shaderProgram.uniformMVMatrix, false,
    modelViewMatrix);
}
function uploadProjectionMatrixToShader() {
    gl.uniformMatrix4fv(shaderProgram.uniformProjMatrix,
    false, projectionMatrix);
}
function drawEarth(r,g,b,a) {
    gl.vertexAttrib4f(shaderProgram.vertexColorAttribute, r, g, b, a);
    gl.bindBuffer(gl.ARRAY_BUFFER, sphereVertexPositionBuffer);
    gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute,
    sphereVertexPositionBuffer.itemSize,
    gl.FLOAT, false, 0, 0);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, sphereIndexPositionBuffer);
    gl.drawElements(gl.TRIANGLES, sphereIndexPositionBuffer.numberOfItems,
    gl.UNSIGNED_SHORT, 0);
}

function drawCube(r,g,b,a) {
    gl.disableVertexAttribArray(shaderProgram.vertexColorAttribute);
    gl.vertexAttrib4f(shaderProgram.vertexColorAttribute, r, g, b, a);
    gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
    gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute,
    cubeVertexPositionBuffer.itemSize,
    gl.FLOAT, false, 0, 0);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
    gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numberOfItems,
    gl.UNSIGNED_SHORT, 0);
}

function drawCylinder(r,g,b,a) {
    gl.vertexAttrib4f(shaderProgram.vertexColorAttribute, r, g, b, a);
    gl.bindBuffer(gl.ARRAY_BUFFER, cylinderVertexPositionBuffer);
    gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute,
    cylinderVertexPositionBuffer.itemSize,
    gl.FLOAT, false, 0, 0);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cylinderIndexPositionBuffer);
    gl.drawElements(gl.TRIANGLES, cylinderIndexPositionBuffer.numberOfItems,
    gl.UNSIGNED_SHORT, 0);
}


function drawPanel(r, g, b, a) {
    gl.vertexAttrib4f(shaderProgram.vertexColorAttribute, r, g, b, a);
    gl.bindBuffer(gl.ARRAY_BUFFER, panelVertexPositionBuffer);
    gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, panelVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, panelIndexBuffer);
    gl.drawElements(gl.TRIANGLES, panelIndexBuffer.numberOfItems, gl.UNSIGNED_SHORT, 0);
}

function drawSatellite() {

    // Draw Cube
    drawCube(1.0, 1.0, 0.0, 1.0);

    // Draw Left Cylinder
    pushModelViewMatrix();
    mat4.translate(modelViewMatrix, [-1, 0, 0]); // Position left cylinder
    mat4.rotateZ(modelViewMatrix, Math.PI / 2);    // Orient cylinder along x-axis
    uploadModelViewMatrixToShader();
    drawCylinder(0.0, 1.0, 0.0, 1.0); // Green cylinder

    // Attach left panel
    pushModelViewMatrix();
    mat4.translate(modelViewMatrix, [0, 2.8, 0]); // Move to cylinder's end
    mat4.rotateY(modelViewMatrix, Math.PI / 1.5);
    uploadModelViewMatrixToShader();
    drawPanel(1.0, 0.0, 0.0, 1.0); // Red panel
    popModelViewMatrix();

    popModelViewMatrix();

    // Draw Right Cylinder
    pushModelViewMatrix();
    mat4.translate(modelViewMatrix, [1, 0, 0]); // Position right cylinder
    mat4.rotateZ(modelViewMatrix, Math.PI / 2);   // Orient cylinder along x-axis
    uploadModelViewMatrixToShader();
    drawCylinder(0.0, 0.0, 1.0, 1.0); // Blue cylinder

    // Attach right panel
    pushModelViewMatrix();
    mat4.translate(modelViewMatrix, [0, -2.8, 0]); // Move to cylinder's end
    mat4.rotateY(modelViewMatrix, Math.PI / 1.5);  
    uploadModelViewMatrixToShader();
    drawPanel(0.0, 1.0, 0.0, 1.0); // Green panel
    popModelViewMatrix();

    popModelViewMatrix();


    pushModelViewMatrix();
    mat4.translate(modelViewMatrix, [0, 0, -3]); // Position right cylinder
    mat4.rotateX(modelViewMatrix, Math.PI / 2);   // Orient cylinder along x-axis
    uploadModelViewMatrixToShader();
    drawCylinder(0.0, 1.0, 1.0, 1.0); // Blue cylinder
    
    popModelViewMatrix();
}

function drawScene() {
    
    gl.viewport(10, 10, gl.viewportWidth, gl.viewportHeight);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    mat4.perspective(60, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, projectionMatrix);
    mat4.identity(modelViewMatrix);
    mat4.lookAt([0, 5, -20], [0, 0, 0], [0, 1, 0], modelViewMatrix);

    pushModelViewMatrix();
    uploadModelViewMatrixToShader();
    uploadProjectionMatrixToShader();
    //drawEarth(0.0, 0.0, 1.0, 1.0);
    drawSatellite();
    
}



function startup() {
    canvas = document.getElementById("myGLCanvas");
    gl = WebGLDebugUtils.makeDebugContext(createGLContext(canvas));
    setupShaders();
    setupBuffers();
    gl.clearColor(0.0, 0.0, 0.0, 1.0);
    gl.enable(gl.DEPTH_TEST);
    drawScene();
    
}
</script>
</head>
<body onload="startup();">
<canvas id="myGLCanvas" width="1000" height="800"></canvas>

</body>
</html>