<!DOCTYPE HTML>
<html lang="en">

<head>
    <style>
        body,
        html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100%;
        }

        canvas {
            display: block;
        }
    </style>
    <title> Super Earth </title>
    <meta charset="utf-8">
    <script src="glMatrix.js"></script>
    <script src="webgl-debug.js"></script>
    <!--Texture Shaders-->
    <script id="shader-vs" type="x-shader/x-vertex">
        attribute vec3 aVertexPosition;
        attribute vec2 aTextureCoord; // Add texture coordinates

        uniform mat4 uMVMatrix;
        uniform mat4 uPMatrix;

        varying vec2 vTextureCoord;

        void main() {
            gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
        vTextureCoord = aTextureCoord; // Pass texture coordinates to fragment shader
        }

    </script>
    <script id="shader-fs" type="x-shader/x-fragment">
        precision mediump float;

        varying vec2 vTextureCoord; // Interpolated texture coordinates from vertex shader
        uniform sampler2D uSampler; // Texture sampler

        void main() {
            gl_FragColor = texture2D(uSampler, vTextureCoord); // Sample texture
        }

    </script>
    <!-- Golden Shaders -->
    <script id="golden-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;

    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;

    void main(void) {
        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
    }
</script>

    <script id="golden-fs" type="x-shader/x-fragment">
    precision mediump float;

    void main(void) {
        gl_FragColor = vec4(1.0, 0.84, 0.0, 1.0); // Solid golden color (RGBA)
    }
</script>
    <script type="text/javascript">

        var gl;
        var canvas;
        var shaderProgram;
        var goldenShaderProgram;
        var sphereVertexPositionBuffer;
        var sphereIndexPositionBuffer;
        var modelViewMatrix;
        var projectionMatrix;
        var modelViewMatrixStack;
        var satelliteAngle = 0;
        var panelVertexPositionBuffer;
        var panelIndexBuffer;
        var elapsedTime = 0;
        var lastTime = 0;

        var satelliteOrbitRadius = 50; // Distance from Earth"s center
        var satelliteOrbitSpeed = 0.001;
        var satelliteOrbitAngle = 0;

        var zoomValue = 100;
        var moveX = 0;
        var moveY = 0;

        var rotateX = 0;
        var rotateY = 0;

        var isPanning = false;

        function createGLContext(canvas) {
            var names = ["webgl", "experimental-webgl"];
            var context = null;
            for (var i = 0; i < names.length; i++) {
                try {
                    context = canvas.getContext(names[i]);
                } catch (e) { }
                if (context) {
                    break;
                }
            }
            if (context) {
                context.viewportWidth = canvas.width;
                context.viewportHeight = canvas.height;
            } else {
                alert("Failed to create WebGL context!");
            }
            return context;
        }
        function loadShaderFromDOM(id) {
            var shaderScript = document.getElementById(id);
            if (!shaderScript) {
                return null;
            }
            var shaderSource = "";
            var currentChild = shaderScript.firstChild;
            while (currentChild) {
                if (currentChild.nodeType == 3) { // 3 corresponds to TEXT_NODE
                    shaderSource += currentChild.textContent;
                }
                currentChild = currentChild.nextSibling;
            }
            var shader;
            if (shaderScript.type == "x-shader/x-fragment") {
                shader = gl.createShader(gl.FRAGMENT_SHADER);
            } else if (shaderScript.type == "x-shader/x-vertex") {
                shader = gl.createShader(gl.VERTEX_SHADER);
            } else {
                return null;
            }
            gl.shaderSource(shader, shaderSource);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                alert(gl.getShaderInfoLog(shader));
                return null;
            }
            return shader;
        }
        function setupShaders() {
            var vertexShader = loadShaderFromDOM("shader-vs");
            var fragmentShader = loadShaderFromDOM("shader-fs");
            shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);
            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                alert("Failed to setup shaders");
            }
            gl.useProgram(shaderProgram);
            shaderProgram.vertexPositionAttribute =
                gl.getAttribLocation(shaderProgram, "aVertexPosition");
            shaderProgram.vertexColorAttribute = gl.getAttribLocation(shaderProgram, "aVertexColor");
            shaderProgram.uniformMVMatrix =
                gl.getUniformLocation(shaderProgram, "uMVMatrix");
            shaderProgram.uniformProjMatrix =
                gl.getUniformLocation(shaderProgram, "uPMatrix");
            shaderProgram.textureCoordAttribute = gl.getAttribLocation(shaderProgram, "aTextureCoord");
            gl.enableVertexAttribArray(shaderProgram.textureCoordAttribute);

            shaderProgram.samplerUniform = gl.getUniformLocation(shaderProgram, "uSampler");
            // Initialise the matrices
            modelViewMatrix = mat4.create();
            projectionMatrix = mat4.create();
            modelViewMatrixStack = [];
            gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);
        }

        function setupGoldenShader() {
            var goldenVertexShader = loadShaderFromDOM("golden-vs");
            var goldenFragmentShader = loadShaderFromDOM("golden-fs");
            goldenShaderProgram = gl.createProgram();

            gl.attachShader(goldenShaderProgram, goldenVertexShader);
            gl.attachShader(goldenShaderProgram, goldenFragmentShader);
            gl.linkProgram(goldenShaderProgram);

            if (!gl.getProgramParameter(goldenShaderProgram, gl.LINK_STATUS)) {
                alert("Failed to setup golden shaders");
            }

            // Get attribute and uniform locations
            goldenShaderProgram.vertexPositionAttribute = gl.getAttribLocation(goldenShaderProgram, "aVertexPosition");
            gl.enableVertexAttribArray(goldenShaderProgram.vertexPositionAttribute);

            goldenShaderProgram.uMVMatrix = gl.getUniformLocation(goldenShaderProgram, "uMVMatrix");
            goldenShaderProgram.uPMatrix = gl.getUniformLocation(goldenShaderProgram, "uPMatrix");
        }

        function pushModelViewMatrix() {
            var copyToPush = mat4.create(modelViewMatrix);
            modelViewMatrixStack.push(copyToPush);
        }
        function popModelViewMatrix() {
            if (modelViewMatrixStack.length == 0) {
                throw "Error popModelViewMatrix() - Stack was empty ";
            }
            modelViewMatrix = modelViewMatrixStack.pop();
        }

        function setupSphereBuffers(radius) {
            // Using gl.Triangles (drawElements) to draw a sphere
            sphereVertexPositionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, sphereVertexPositionBuffer);
            var sphereVertexPosition = [];
            var r = radius;
            var m = 15;
            var n = 15;

            for (var i = 0; i <= m; i++) {
                for (var j = 0; j <= n; j++) {
                    // Calculate x, y, and z
                    var theta = (i * Math.PI) / m;         // Latitude angle
                    var phi = (2 * j * Math.PI) / n;      // Longitude angle
                    var x = r * Math.sin(theta) * Math.cos(phi);
                    var y = r * Math.cos(theta);
                    var z = r * Math.sin(theta) * Math.sin(phi);
                    sphereVertexPosition.push(x, y, z);
                }
            }

            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(sphereVertexPosition), gl.STATIC_DRAW);
            sphereVertexPositionBuffer.itemSize = 3;
            sphereVertexPositionBuffer.numberOfItems = (m + 1) * (n + 1);

            // Add texture coordinates
            sphereTextureCoordBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, sphereTextureCoordBuffer);
            var sphereTextureCoords = [];
            for (var i = 0; i <= m; i++) {
                for (var j = 0; j <= n; j++) {
                    var u = j / n; // Horizontal texture coordinate
                    var v = i / m; // Vertical texture coordinate
                    sphereTextureCoords.push(u, v);
                }
            }

            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(sphereTextureCoords), gl.STATIC_DRAW);
            sphereTextureCoordBuffer.itemSize = 2;
            sphereTextureCoordBuffer.numberOfItems = (m + 1) * (n + 1);

            // Set up indices for drawing elements
            sphereIndexPositionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, sphereIndexPositionBuffer);
            var sphereIndexPosition = [];
            for (var i = 0; i < m; i++) {
                for (var j = 0; j < n; j++) {
                    var v1 = i * (n + 1) + j;
                    var v2 = v1 + n + 1;
                    var v3 = v1 + 1;
                    var v4 = v2 + 1;

                    sphereIndexPosition.push(v1, v2, v3);
                    sphereIndexPosition.push(v3, v2, v4);
                }
            }

            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(sphereIndexPosition), gl.STATIC_DRAW);
            sphereIndexPositionBuffer.itemSize = 3;
            sphereIndexPositionBuffer.numberOfItems = m * n * 2 * 3;

            // Add normals for lighting calculations
            var sphereNormalData = [];
            for (var i = 0; i <= m; i++) {
                for (var j = 0; j <= n; j++) {
                    var theta = (i * Math.PI) / m;
                    var phi = (2 * j * Math.PI) / n;
                    var nx = Math.sin(theta) * Math.cos(phi);
                    var ny = Math.cos(theta);
                    var nz = Math.sin(theta) * Math.sin(phi);
                    sphereNormalData.push(nx, ny, nz);
                }
            }

            sphereNormalBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, sphereNormalBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(sphereNormalData), gl.STATIC_DRAW);
            sphereNormalBuffer.itemSize = 3;
            sphereNormalBuffer.numberOfItems = (m + 1) * (n + 1);
        }

        function setupCubeBuffers() {
            cubeVertexPositionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
            var cubeVertexPosition = [
                3.0, 3.0, 3.0, //v0
                -3.0, 3.0, 3.0, //v3
                -3.0, -3.0, 3.0, //v2
                3.0, -3.0, 3.0, //v3
                3.0, 3.0, -3.0, //v4
                -3.0, 3.0, -3.0, //v5
                -3.0, -3.0, -3.0, //v6
                3.0, -3.0, -3.0, //v7
            ];
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(cubeVertexPosition),
                gl.STATIC_DRAW);
            cubeVertexPositionBuffer.itemSize = 3;
            cubeVertexPositionBuffer.numberOfItems = 8;
            cubeVertexIndexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);

            //For simplicity, each face will be drawn as gl_TRIANGLES, therefore
            //the indices for each triangle are specified.
            var cubeVertexIndices = [
                0, 1, 2, 0, 2, 3, // Front face
                4, 6, 5, 4, 7, 6, // Back face
                1, 5, 6, 1, 6, 2, //left
                0, 3, 7, 0, 7, 4, //right
                0, 5, 1, 0, 4, 5, //top
                3, 2, 6, 3, 6, 7 //bottom
            ];
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cubeVertexIndices),
                gl.STATIC_DRAW);
            cubeVertexIndexBuffer.itemSize = 1;
            cubeVertexIndexBuffer.numberOfItems = 36;
        }

        function setupCylinderBuffers() {
            cylinderVertexPositionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, cylinderVertexPositionBuffer);

            var radius = 0.1;
            var height = 1.5;
            var numSegments = 36;
            var cylinderVertices = [];
            var angleStep = (2 * Math.PI) / numSegments;

            // Generate the cylinder vertices
            for (let i = 0; i <= numSegments; i++) {
                let angle = i * angleStep;
                let x = Math.cos(angle) * radius;
                let z = Math.sin(angle) * radius;

                // Bottom circle
                cylinderVertices.push(x, -height / 2, z);

                // Top circle
                cylinderVertices.push(x, height / 2, z);
            }

            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(cylinderVertices), gl.STATIC_DRAW);
            cylinderVertexPositionBuffer.itemSize = 3;
            cylinderVertexPositionBuffer.numberOfItems = (numSegments + 1) * 2;

            // Generate indices
            cylinderIndexPositionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cylinderIndexPositionBuffer);
            var cylinderIndices = [];

            for (let i = 0; i < numSegments; i++) {
                // Side triangles
                let p1 = i * 2;
                let p2 = p1 + 1;
                let p3 = (i + 1) * 2;
                let p4 = p3 + 1;

                cylinderIndices.push(p1, p2, p3);
                cylinderIndices.push(p3, p2, p4);
            }

            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cylinderIndices), gl.STATIC_DRAW);
            cylinderIndexPositionBuffer.itemSize = 3;
            cylinderIndexPositionBuffer.numberOfItems = cylinderIndices.length;
        }

        function setupPanelBuffers() {
            panelVertexPositionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, panelVertexPositionBuffer);

            const width = 2.0;   // Half the width
            const height = 8.0;  // Half the height
            const depth = 0.2;   // Thickness

            // Define vertices for a rectangular prism
            var panelVertexPosition = [
                // Front face (z = depth/2)
                width, height, depth / 2,   // v0 (top-right front)
                -width, height, depth / 2,  // v1 (top-left front)
                -width, -height, depth / 2, // v2 (bottom-left front)
                width, -height, depth / 2,  // v3 (bottom-right front)

                // Back face (z = -depth/2)
                width, height, -depth / 2,   // v4 (top-right back)
                -width, height, -depth / 2,  // v5 (top-left back)
                -width, -height, -depth / 2, // v6 (bottom-left back)
                width, -height, -depth / 2   // v7 (bottom-right back)
            ];

            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(panelVertexPosition), gl.STATIC_DRAW);
            panelVertexPositionBuffer.itemSize = 3;
            panelVertexPositionBuffer.numberOfItems = 8;

            // Define indices for the faces of the rectangular prism
            panelIndexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, panelIndexBuffer);

            const panelIndices = [
                // Front face
                0, 1, 2, 0, 2, 3,
                // Back face
                4, 6, 5, 4, 7, 6,
                // Top face
                0, 4, 5, 0, 5, 1,
                // Bottom face
                3, 2, 6, 3, 6, 7,
                // Right face
                0, 3, 7, 0, 7, 4,
                // Left face
                1, 5, 6, 1, 6, 2
            ];

            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(panelIndices), gl.STATIC_DRAW);
            panelIndexBuffer.itemSize = 1;
            panelIndexBuffer.numberOfItems = 36;

            // Texture coordinates (for front and back faces only)
            panelTextureCoordBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, panelTextureCoordBuffer);

            var panelTextureCoords = [
                // Front face
                1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0,
                // Back face
                1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0,
                // Top face
                1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0,
                // Bottom face
                1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0,
                // Right face
                1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0,
                // Left face
                1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0
            ];

            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(panelTextureCoords), gl.STATIC_DRAW);
            panelTextureCoordBuffer.itemSize = 2;
            panelTextureCoordBuffer.numberOfItems = 8;
        }



        function setupDishBuffers() {
            dishVertexPositionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, dishVertexPositionBuffer);

            var radius = 2;
            var numRings = 20;
            var numSegments = 36;
            var curvature = 0.5;
            var dishVertices = [];
            var angleStep = (2 * Math.PI) / numSegments;

            // Generate dish vertices
            for (let ring = 0; ring <= numRings; ring++) {
                let r = (ring / numRings) * radius; // Radius at this ring
                let z = -curvature * (1 - (ring / numRings)) ** 2; // Curved depth on z-axis

                for (let segment = 0; segment <= numSegments; segment++) {
                    let angle = segment * angleStep;
                    let x = r * Math.cos(angle); // x position
                    let y = r * Math.sin(angle); // y position

                    dishVertices.push(x, y, z);
                }
            }

            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(dishVertices), gl.STATIC_DRAW);
            dishVertexPositionBuffer.itemSize = 3;
            dishVertexPositionBuffer.numberOfItems = (numRings + 1) * (numSegments + 1);

            // Generate indices
            dishIndexPositionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, dishIndexPositionBuffer);

            var dishIndices = [];

            for (let ring = 0; ring < numRings; ring++) {
                for (let segment = 0; segment < numSegments; segment++) {
                    let p1 = ring * (numSegments + 1) + segment;
                    let p2 = p1 + numSegments + 1;
                    let p3 = p1 + 1;
                    let p4 = p2 + 1;

                    dishIndices.push(p1, p2, p3); // Triangle 1
                    dishIndices.push(p3, p2, p4); // Triangle 2
                }
            }

            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(dishIndices), gl.STATIC_DRAW);
            dishIndexPositionBuffer.itemSize = 1;
            dishIndexPositionBuffer.numberOfItems = dishIndices.length;
        }

        function setupBuffers() {
            setupSphereBuffers(30);
            setupCubeBuffers();

            setupCylinderBuffers(0.1);
            setupCylinderBuffers(0.2);

            setupPanelBuffers();

            setupDishBuffers();
        }

        function uploadModelViewMatrixToShader() {
            gl.uniformMatrix4fv(shaderProgram.uniformMVMatrix, false,
                modelViewMatrix);
        }
        function uploadProjectionMatrixToShader() {
            gl.uniformMatrix4fv(shaderProgram.uniformProjMatrix, false, projectionMatrix);
        }

        var solarPanelTexture;
        var earthTexture;

        function setupTextures() {
            solarPanelTexture = gl.createTexture();
            solarPanelImage = new Image();
            solarPanelImage.onload = function () {
                gl.bindTexture(gl.TEXTURE_2D, solarPanelTexture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, solarPanelImage);

                // Texture parameters
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

                gl.bindTexture(gl.TEXTURE_2D, null);
            };
            solarPanelImage.src = "solarPanel.jpg";
            console.log("solar panel texture loaded!!!!!!!");

            earthTexture = gl.createTexture();
            earthTexture.image = new Image();
            earthTexture.image.onload = function () {
                handleTextureLoaded(earthTexture);
            }
            earthTexture.image.src = "earth.jpg";
            console.log("earth texture loaded!1");
        }

        function handleTextureLoaded(texture) {
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.image);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
            gl.generateMipmap(gl.TEXTURE_2D);
            gl.bindTexture(gl.TEXTURE_2D, null);
        }

        function drawSphere() {
            gl.bindBuffer(gl.ARRAY_BUFFER, sphereVertexPositionBuffer);
            gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute,
                sphereVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, sphereTextureCoordBuffer);
            gl.vertexAttribPointer(shaderProgram.textureCoordAttribute,
                sphereTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, earthTexture);
            gl.uniform1i(shaderProgram.samplerUniform, 0);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, sphereIndexPositionBuffer);
            gl.drawElements(gl.TRIANGLES, sphereIndexPositionBuffer.numberOfItems,
                gl.UNSIGNED_SHORT, 0);
        }

        function drawCube() {
            gl.useProgram(goldenShaderProgram);

            gl.uniformMatrix4fv(goldenShaderProgram.uMVMatrix, false, modelViewMatrix);
            gl.uniformMatrix4fv(goldenShaderProgram.uPMatrix, false, projectionMatrix);

            gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
            gl.vertexAttribPointer(goldenShaderProgram.vertexPositionAttribute,
                cubeVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);

            gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numberOfItems, gl.UNSIGNED_SHORT, 0);
        
            gl.useProgram(shaderProgram);
        }



        function drawCylinder(r, g, b, a) {
            gl.vertexAttrib4f(shaderProgram.vertexColorAttribute, r, g, b, a);
            gl.bindBuffer(gl.ARRAY_BUFFER, cylinderVertexPositionBuffer);
            gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute,
                cylinderVertexPositionBuffer.itemSize,
                gl.FLOAT, false, 0, 0);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cylinderIndexPositionBuffer);
            gl.drawElements(gl.TRIANGLES, cylinderIndexPositionBuffer.numberOfItems,
                gl.UNSIGNED_SHORT, 0);
        }

        function drawPanel() {
            gl.bindBuffer(gl.ARRAY_BUFFER, panelVertexPositionBuffer);
            gl.vertexAttribPointer(
                shaderProgram.vertexPositionAttribute,
                panelVertexPositionBuffer.itemSize,
                gl.FLOAT, false, 0, 0
            );

            gl.bindBuffer(gl.ARRAY_BUFFER, panelTextureCoordBuffer);
            gl.vertexAttribPointer(
                shaderProgram.textureCoordAttribute,
                panelTextureCoordBuffer.itemSize,
                gl.FLOAT, false, 0, 0
            );

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, solarPanelTexture);
            gl.uniform1i(shaderProgram.samplerUniform, 0);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, panelIndexBuffer);
            gl.drawElements(gl.TRIANGLES, panelIndexBuffer.numberOfItems, gl.UNSIGNED_SHORT, 0);
        }


        function drawDish(r, g, b, a) {
            gl.vertexAttrib4f(shaderProgram.vertexColorAttribute, r, g, b, a);

            gl.bindBuffer(gl.ARRAY_BUFFER, dishVertexPositionBuffer);
            gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute,
                dishVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, dishIndexPositionBuffer);
            gl.drawElements(gl.TRIANGLES, dishIndexPositionBuffer.numberOfItems, gl.UNSIGNED_SHORT, 0);
        }

        function drawSatellite(orbitRadius) {
            satelliteOrbitRadius = orbitRadius; // Distance from Earth"s center

            pushModelViewMatrix();

            const satelliteX = satelliteOrbitRadius * Math.cos(satelliteOrbitAngle);
            const satelliteZ = satelliteOrbitRadius * Math.sin(satelliteOrbitAngle);

            mat4.translate(modelViewMatrix, [satelliteX, 0, satelliteZ]);

            mat4.rotateY(modelViewMatrix, -satelliteOrbitAngle);

            uploadModelViewMatrixToShader();
            drawCube(1.0, 1.0, 0.0, 1.0);


            pushModelViewMatrix();
            mat4.translate(modelViewMatrix, [0, 0, -3.5]); // Position left cylinder
            mat4.rotateZ(modelViewMatrix, Math.PI / 2);
            mat4.rotateX(modelViewMatrix, Math.PI / 2);
            uploadModelViewMatrixToShader();
            drawCylinder(0.0, 1.0, 0.0, 1.0);

            pushModelViewMatrix();
            mat4.translate(modelViewMatrix, [0, -8.8, 0]); // Move to cylinder"s end
            mat4.rotateY(modelViewMatrix, Math.PI / 2);
            uploadModelViewMatrixToShader();
            drawPanel();

            popModelViewMatrix();
            popModelViewMatrix();

            pushModelViewMatrix();
            mat4.translate(modelViewMatrix, [0, 0, 3.5]); // Position left cylinder
            mat4.rotateZ(modelViewMatrix, Math.PI / 2);
            mat4.rotateX(modelViewMatrix, Math.PI / 2);
            uploadModelViewMatrixToShader();
            drawCylinder(0.0, 0.0, 1.0, 1.0);

            pushModelViewMatrix();
            mat4.translate(modelViewMatrix, [0, 8.8, 0]); // Move to cylinder"s end
            mat4.rotateY(modelViewMatrix, Math.PI / 2);
            uploadModelViewMatrixToShader();
            drawPanel();

            popModelViewMatrix();
            popModelViewMatrix();

            pushModelViewMatrix();
            mat4.translate(modelViewMatrix, [-3.5, 0, 0]);
            mat4.rotateZ(modelViewMatrix, Math.PI / 2);
            uploadModelViewMatrixToShader();
            drawCylinder(0.0, 1.0, 1.0, 1.0);

            pushModelViewMatrix();
            mat4.translate(modelViewMatrix, [0, 1.2, 0]);
            mat4.rotateX(modelViewMatrix, Math.PI / -2);
            uploadModelViewMatrixToShader();
            drawDish(1.0, 1.0, 1.0, 1.0);

            popModelViewMatrix();
            popModelViewMatrix();

        }

        function drawEarth() {
            var angle = elapsedTime * 0.0005;
            pushModelViewMatrix();
            mat4.rotateY(modelViewMatrix, angle);
            uploadModelViewMatrixToShader();
            drawSphere();
            popModelViewMatrix();
        }

        function drawScene(zoomValue, rotateX, rotateY, moveX, moveY) {
            gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            mat4.perspective(60, gl.viewportWidth / gl.viewportHeight, 0.1, 500.0, projectionMatrix);
            mat4.identity(modelViewMatrix);
            mat4.lookAt([rotateX, rotateY, zoomValue], [moveX, moveY, 0], [0, 1, 0], modelViewMatrix);
            uploadProjectionMatrixToShader();
            uploadModelViewMatrixToShader();
            drawEarth();
            drawSatellite(satelliteOrbitRadius);
        }

        function handleUserControls() {
            document.addEventListener("keydown", function (event) {
                if (event.key === "ArrowRight") {
                    satelliteOrbitRadius += 1;
                    console.log("moving further from earth");
                } else if (event.key === "ArrowLeft") {
                    if (satelliteOrbitRadius > 40) {
                        satelliteOrbitRadius -= 1;
                        console.log("moving closer to earth");
                    } else {
                        console.log("TOO CLOSE BRUH!!!!!!!!!!!!!!!!!!!");
                    }
                }
            });

            document.addEventListener("keydown", function (event) {
                if (event.key === "ArrowUp") {
                    satelliteOrbitSpeed += 0.001;
                    console.log("speedup!!!!!!!!!1");
                } else if (event.key === "ArrowDown") {
                    if (satelliteOrbitSpeed > 0.001) {
                        satelliteOrbitSpeed -= 0.001;
                        console.log("slowdown!!");
                    } else {
                        console.log("slow down limit reached, do u want to crash to the earth? :>");
                    }
                }
            });

            document.addEventListener("wheel", function (event) {
                if (event.deltaY > 0) {
                    zoomValue += 5;
                    console.log("user holding down shift and scrolling up");
                } else if (event.deltaY < 0) {
                    zoomValue -= 5;
                    console.log("user holding down shift and scrolling down");
                }
            });


            document.addEventListener("mousedown", function (event) {
                if (event.shiftKey) {
                    let startX = event.clientX;
                    let lastX = startX;
                    document.addEventListener("mousemove", onMouseMove);

                    function onMouseMove(event) {
                        if (event.clientX < lastX) {
                            moveX -= 5;
                            console.log("user holding down shift and dragging left");
                        } else if (event.clientX > lastX) {
                            moveX += 5;
                            console.log("user holding down shift and dragging right");
                        }
                        lastX = event.clientX;
                    }
                }
                else if (event.altKey) {
                    let startY = event.clientY;
                    let lastY = startY;
                    document.addEventListener("mousemove", onMouseMove);

                    function onMouseMove(event) {
                        if (event.clientY < lastY) {
                            moveY += 5;
                            console.log("user alt dragging up");
                        } else if (event.clientY > lastY) {
                            moveY -= 5;
                            console.log("user alt dragging down");
                        }
                        lastY = event.clientY;
                    }
                } else {
                    let startY = event.clientY;
                    let lastY = startY;
                    let startX = event.clientX;
                    let lastX = startX;

                    document.addEventListener("mousemove", onMouseMove);

                    function onMouseMove(event) {
                        if (event.clientY < lastY) {
                            if (rotateY < 200) {
                                rotateY += 5;
                                console.log("user JUST dragging up", rotateY);
                            } else {
                                console.log("TOO HIGH BRUH!!!!!!!!!!!!!!!!!!!");
                            }
                        } else if (event.clientY > lastY) {
                            if (rotateY > -200) {
                                rotateY -= 5;
                                console.log("user JUST dragging down", rotateY);
                            } else {
                                console.log("TOO LOW BRUH!!!!!!!!!!!!!!!!!!!");
                            }
                        }
                        lastY = event.clientY;

                        if (event.clientX < lastX) {
                            if (rotateX > -200) {
                                rotateX -= 5;
                                console.log("user JUST dragging left", rotateX);
                            } else {
                                console.log("TOO LEFT BRUH!!!!!!!!!!!!!!!!!!!");
                            }
                        } else if (event.clientX > lastX) {
                            if (rotateX < 200) {
                                rotateX += 5;
                                console.log("user JUST dragging right", rotateX);
                            } else {
                                console.log("TOO RIGHT BRUH!!!!!!!!!!!!!!!!!!!");
                            }
                        }
                        lastX = event.clientX;
                    }
                }
                document.addEventListener("mouseup", function () {
                    document.removeEventListener("mousemove", onMouseMove);
                }, { once: true });
            });
        }

        function animate() {
            var timeNow = new Date().getTime();
            if (lastTime != 0) {
                var elapsed = timeNow - lastTime;
                elapsedTime += elapsed;
                satelliteOrbitAngle += elapsed * satelliteOrbitSpeed; // Update satellite angle
            }
            lastTime = timeNow;
        }

        function tick() {
            requestAnimationFrame(tick);
            drawScene(zoomValue, rotateX, rotateY, moveX, moveY);
            animate();
        }

        function startup() {
            canvas = document.getElementById("myGLCanvas");
            gl = createGLContext(canvas);
            setupShaders();

            setupBuffers();
            setupTextures();
            setupGoldenShader();
            handleUserControls();
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.enable(gl.DEPTH_TEST);
            tick();
        }
    </script>
</head>

<body onload="startup();">
    <canvas id="myGLCanvas" width="1920" height="1000"></canvas>

</body>

</html>