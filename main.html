<!DOCTYPE HTML>
<html lang="en">
<head>
    <style>
        /* Styling to make it full screen (kind of)*/
        body,
        html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100%;
        }

        canvas {
            display: block;
        }
    </style>
    <title> Super Earth </title>
    <meta charset="utf-8">
    <script src="glMatrix.js"></script>
    <script src="webgl-debug.js"></script>
    <!--Texture Shaders-->
    <script id="shader-vs" type="x-shader/x-vertex">
        attribute vec3 aVertexPosition;
        attribute vec3 aVertexNormal;     
        attribute vec2 aTextureCoord;     

        uniform mat4 uMVMatrix;           
        uniform mat4 uPMatrix;            
        uniform mat3 uNMatrix;            

        varying vec3 vTransformedNormal;  
        varying vec3 vPositionEye;        
        varying vec2 vTextureCoord;       

        void main(void) {
            vec4 positionEye = uMVMatrix * vec4(aVertexPosition, 1.0);
            vPositionEye = positionEye.xyz;

            vTransformedNormal = uNMatrix * aVertexNormal;

            vTextureCoord = aTextureCoord;

            gl_Position = uPMatrix * positionEye;
        }

    </script>
    <script id="shader-fs" type="x-shader/x-fragment">
        precision mediump float;

        uniform sampler2D uSampler;
        uniform vec3 uLightDirection;
        uniform vec3 uLightColor;
        uniform vec3 uAmbientLightColor;
        uniform vec3 uSpecularColor;

        varying vec3 vTransformedNormal;
        varying vec3 vPositionEye;
        varying vec2 vTextureCoord;

        void main(void) {
            vec3 normal = normalize(vTransformedNormal);
            vec3 lightDir = normalize(-uLightDirection);

            vec3 ambient = uAmbientLightColor;

            float diffuseFactor = max(dot(normal, lightDir), 0.0);
            vec3 diffuse = uLightColor * diffuseFactor;

            vec3 viewDir = normalize(-vPositionEye);
            vec3 reflectionDir = reflect(-lightDir, normal);
            float specFactor = pow(max(dot(viewDir, reflectionDir), 0.0), 16.0);
            vec3 specular = uSpecularColor * specFactor;

            vec3 lighting = ambient + diffuse + specular;

            vec4 solidColor = vec4(1.0, 1.0, 1.0, 1.0);
            vec4 texelColor = texture2D(uSampler, vTextureCoord);
            if (texelColor.a == 0.0) { 
                gl_FragColor = vec4(solidColor.rgb * lighting, solidColor.a);
            } else {
                gl_FragColor = vec4(texelColor.rgb * lighting, texelColor.a);
            }
        }

    </script>
    <!-- Golden Shaders -->
    <script id="golden-vs" type="x-shader/x-vertex">
        attribute vec3 aVertexPosition;
        attribute vec3 aVertexNormal;

        uniform mat4 uMVMatrix;   
        uniform mat4 uPMatrix;    
        uniform mat3 uNMatrix;   

        varying vec3 vTransformedNormal;
        varying vec3 vPositionEye;

        void main(void) {
            vec4 positionEye = uMVMatrix * vec4(aVertexPosition, 1.0);
            vPositionEye = positionEye.xyz;

            vTransformedNormal = normalize(uNMatrix * aVertexNormal);

            gl_Position = uPMatrix * positionEye;
        }

    </script>

    <script id="golden-fs" type="x-shader/x-fragment">
        precision mediump float;

        varying vec3 vTransformedNormal; 
        varying vec3 vPositionEye;       

        uniform vec3 uLightDirection;    
        uniform vec3 uLightColor;        

        const vec3 ambientColor = vec3(0.3, 0.2, 0.1);  
        const vec3 goldColor = vec3(1.0, 0.843, 0.0);  
        const vec3 specularColor = vec3(1.0, 1.0, 1.0);

        void main(void) {
            vec3 normal = normalize(vTransformedNormal);
            vec3 lightDir = normalize(-uLightDirection);

            vec3 viewDir = normalize(-vPositionEye);

            vec3 ambient = ambientColor;

            float diffuseFactor = max(dot(normal, lightDir), 0.0);
            vec3 diffuse = goldColor * diffuseFactor;

            vec3 reflectionDir = reflect(-lightDir, normal);
            float specFactor = pow(max(dot(viewDir, reflectionDir), 0.0), 16.0);
            vec3 specular = specularColor * specFactor;

            vec3 lighting = ambient + diffuse + specular;

            gl_FragColor = vec4(lighting, 1.0);
        }

        
        
    </script>
    <script type="text/javascript">

        let gl;
        let canvas;
        let shaderProgram;
        let goldenShaderProgram;
        let sphereVertexPositionBuffer;
        let sphereIndexPositionBuffer;
        let modelViewMatrix;
        let projectionMatrix;
        let modelViewMatrixStack;
        let panelVertexPositionBuffer;
        let panelIndexBuffer;
        let elapsedTime = 0;
        let lastTime = 0;

        let satelliteOrbitRadius = 50;
        let satelliteOrbitSpeed = 0.0005;
        let satelliteOrbitAngle = 0;

        let zoomValue = 100;
        let moveX = 0;
        let moveY = 0;

        let rotateX = 0;
        let rotateY = 0;
        // initial setup
        function createGLContext(canvas) {
            let names = ["webgl", "experimental-webgl"];
            let context = null;
            for (let i = 0; i < names.length; i++) {
                try {
                    context = canvas.getContext(names[i]);
                } catch (e) { }
                if (context) {
                    break;
                }
            }
            if (context) {
                context.viewportWidth = canvas.width;
                context.viewportHeight = canvas.height;
            } else {
                alert("Failed to create WebGL context!");
            }
            return context;
        }
        
        function loadShaderFromDOM(id) {
            let shaderScript = document.getElementById(id);
            if (!shaderScript) {
                return null;
            }
            let shaderSource = "";
            let currentChild = shaderScript.firstChild;
            while (currentChild) {
                if (currentChild.nodeType == 3) {
                    shaderSource += currentChild.textContent;
                }
                currentChild = currentChild.nextSibling;
            }
            let shader;
            if (shaderScript.type == "x-shader/x-fragment") {
                shader = gl.createShader(gl.FRAGMENT_SHADER);
            } else if (shaderScript.type == "x-shader/x-vertex") {
                shader = gl.createShader(gl.VERTEX_SHADER);
            } else {
                return null;
            }
            gl.shaderSource(shader, shaderSource);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                alert(gl.getShaderInfoLog(shader));
                return null;
            }
            return shader;
        }

        function setupShaders() {
            let vertexShader = loadShaderFromDOM("shader-vs");
            let fragmentShader = loadShaderFromDOM("shader-fs");
            shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);
            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                alert("Failed to setup shaders");
            }
            gl.useProgram(shaderProgram);

            shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");

            shaderProgram.vertexNormalAttribute = gl.getAttribLocation(shaderProgram, "aVertexNormal");

            shaderProgram.vertexTextureCoordAttribute = gl.getAttribLocation(shaderProgram, "aTextureCoord");

            shaderProgram.uLightDirection = gl.getUniformLocation(shaderProgram, "uLightDirection");
            shaderProgram.uLightColor = gl.getUniformLocation(shaderProgram, "uLightColor");
            shaderProgram.uAmbientLightColor = gl.getUniformLocation(shaderProgram, "uAmbientLightColor");
            shaderProgram.uSpecularColor = gl.getUniformLocation(shaderProgram, "uSpecularColor");


            shaderProgram.uniformMVMatrix = gl.getUniformLocation(shaderProgram, "uMVMatrix");
            shaderProgram.uniformProjMatrix = gl.getUniformLocation(shaderProgram, "uPMatrix");
            shaderProgram.uLightPosition = gl.getUniformLocation(shaderProgram, "uLightPosition");
            shaderProgram.uAmbientLightColor = gl.getUniformLocation(shaderProgram, "uAmbientLightColor");
            shaderProgram.uDiffuseLightColor = gl.getUniformLocation(shaderProgram, "uDiffuseLightColor");
            shaderProgram.uSpecularLightColor = gl.getUniformLocation(shaderProgram, "uSpecularLightColor");
            shaderProgram.uNMatrix = gl.getUniformLocation(shaderProgram, "uNMatrix");


            shaderProgram.samplerUniform = gl.getUniformLocation(shaderProgram, "uSampler");
            // Initialise the matrices
            modelViewMatrix = mat4.create();
            projectionMatrix = mat4.create();
            modelViewMatrixStack = [];
            gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);

            shaderProgram.uLightDirection = gl.getUniformLocation(shaderProgram, "uLightDirection");
            shaderProgram.uLightColor = gl.getUniformLocation(shaderProgram, "uLightColor");
        }

        function setupGoldenShader() {
            let goldenVertexShader = loadShaderFromDOM("golden-vs");
            let goldenFragmentShader = loadShaderFromDOM("golden-fs");
            goldenShaderProgram = gl.createProgram();

            gl.attachShader(goldenShaderProgram, goldenVertexShader);
            gl.attachShader(goldenShaderProgram, goldenFragmentShader);
            gl.linkProgram(goldenShaderProgram);

            if (!gl.getProgramParameter(goldenShaderProgram, gl.LINK_STATUS)) {
                alert("Failed to setup golden shaders");
            }

            goldenShaderProgram.vertexPositionAttribute = gl.getAttribLocation(goldenShaderProgram, "aVertexPosition");
            gl.enableVertexAttribArray(goldenShaderProgram.vertexPositionAttribute);

            goldenShaderProgram.vertexNormalAttribute = gl.getAttribLocation(goldenShaderProgram, "aVertexNormal");
            gl.enableVertexAttribArray(goldenShaderProgram.vertexNormalAttribute);

            goldenShaderProgram.uMVMatrix = gl.getUniformLocation(goldenShaderProgram, "uMVMatrix");
            goldenShaderProgram.uPMatrix = gl.getUniformLocation(goldenShaderProgram, "uPMatrix");
            goldenShaderProgram.uNMatrix = gl.getUniformLocation(goldenShaderProgram, "uNMatrix");
            goldenShaderProgram.uLightDirection = gl.getUniformLocation(goldenShaderProgram, "uLightDirection");
            goldenShaderProgram.uLightColor = gl.getUniformLocation(goldenShaderProgram, "uLightColor");

        }

        function setUpLighting() {
            let lightOrigin = [-5, -5, 0];
            let lightColor = [1, 1, 1];
            let ambientLightColor = [0.4, 0.4, 0.4];
            let specularColor = [0.5, 0.5, 0.5];

            gl.uniform3fv(shaderProgram.uLightDirection, lightOrigin);
            gl.uniform3fv(shaderProgram.uLightColor, lightColor);
            gl.uniform3fv(shaderProgram.uAmbientLightColor, ambientLightColor);
            gl.uniform3fv(shaderProgram.uSpecularColor, specularColor);
        }

        function pushModelViewMatrix() {
            let copyToPush = mat4.create(modelViewMatrix);
            modelViewMatrixStack.push(copyToPush);
        }

        function popModelViewMatrix() {
            if (modelViewMatrixStack.length == 0) {
                throw "Error popModelViewMatrix() - Stack was empty ";
            }
            modelViewMatrix = modelViewMatrixStack.pop();
        }

        // BUFFER SETUP !!!!!!!!!!!!!!!!!!!!!!!1

        function setupSphereBuffers(radius) {
            // Using gl.Triangles (drawElements) to draw a sphere
            sphereVertexPositionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, sphereVertexPositionBuffer);
            let sphereVertexPosition = [];
            let r = radius;
            let m = 15;
            let n = 15;

            for (let i = 0; i <= m; i++) {
                for (let j = 0; j <= n; j++) {
                    // Calculate x, y, and z
                    let theta = (i * Math.PI) / m;  
                    let phi = (2 * j * Math.PI) / n;
                    let x = r * Math.sin(theta) * Math.cos(phi);
                    let y = r * Math.cos(theta);
                    let z = r * Math.sin(theta) * Math.sin(phi);
                    sphereVertexPosition.push(x, y, z);
                }
            }

            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(sphereVertexPosition), gl.STATIC_DRAW);
            sphereVertexPositionBuffer.itemSize = 3;
            sphereVertexPositionBuffer.numberOfItems = (m + 1) * (n + 1);

            // Add texture coordinates
            sphereTextureCoordBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, sphereTextureCoordBuffer);
            let sphereTextureCoords = [];
            for (let i = 0; i <= m; i++) {
                for (let j = 0; j <= n; j++) {
                    let u = j / n; // Horizontal texture coordinate
                    let v = i / m; // Vertical texture coordinate
                    sphereTextureCoords.push(u, v);
                }
            }

            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(sphereTextureCoords), gl.STATIC_DRAW);
            sphereTextureCoordBuffer.itemSize = 2;
            sphereTextureCoordBuffer.numberOfItems = (m + 1) * (n + 1);

            // Set up indices for drawing elements
            sphereIndexPositionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, sphereIndexPositionBuffer);
            let sphereIndexPosition = [];
            for (let i = 0; i < m; i++) {
                for (let j = 0; j < n; j++) {
                    let v1 = i * (n + 1) + j;
                    let v2 = v1 + n + 1;
                    let v3 = v1 + 1;
                    let v4 = v2 + 1;

                    sphereIndexPosition.push(v1, v2, v3);
                    sphereIndexPosition.push(v3, v2, v4);
                }
            }

            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(sphereIndexPosition), gl.STATIC_DRAW);
            sphereIndexPositionBuffer.itemSize = 3;
            sphereIndexPositionBuffer.numberOfItems = m * n * 2 * 3;

            // Add normals for lighting calculations
            let sphereNormalData = []; // Array to hold the sphere normals

            for (let i = 0; i < sphereVertexPosition.length; i += 3) {
                let x = sphereVertexPosition[i];
                let y = sphereVertexPosition[i + 1];
                let z = sphereVertexPosition[i + 2];

                // Normalize the vertex position to calculate the normal
                let length = Math.sqrt(x * x + y * y + z * z);
                sphereNormalData.push(x / length, y / length, z / length);
            }


            sphereNormalBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, sphereNormalBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(sphereNormalData), gl.STATIC_DRAW);
            sphereNormalBuffer.itemSize = 3;
            sphereNormalBuffer.numItems = sphereNormalData.length / 3;

        }

        function setupCubeBuffers() {
            // Vertex positions for a cube (centered at origin)
            cubeVertexPositionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);

            const cubeVertexPosition = [
                // Front face
                3.0, 3.0, 3.0, -3.0, 3.0, 3.0, -3.0, -3.0, 3.0, 3.0, -3.0, 3.0,
                // Back face
                3.0, 3.0, -3.0, -3.0, 3.0, -3.0, -3.0, -3.0, -3.0, 3.0, -3.0, -3.0,
                // Top face
                3.0, 3.0, -3.0, 3.0, 3.0, 3.0, -3.0, 3.0, 3.0, -3.0, 3.0, -3.0,
                // Bottom face
                3.0, -3.0, -3.0, 3.0, -3.0, 3.0, -3.0, -3.0, 3.0, -3.0, -3.0, -3.0,
                // Right face
                3.0, 3.0, -3.0, 3.0, 3.0, 3.0, 3.0, -3.0, 3.0, 3.0, -3.0, -3.0,
                // Left face
                -3.0, 3.0, -3.0, -3.0, 3.0, 3.0, -3.0, -3.0, 3.0, -3.0, -3.0, -3.0
            ];

            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(cubeVertexPosition), gl.STATIC_DRAW);
            cubeVertexPositionBuffer.itemSize = 3;
            cubeVertexPositionBuffer.numberOfItems = 24;

            cubeNormalBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, cubeNormalBuffer);

            const cubeNormals = [
                // Front face normals
                0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0,
                // Back face normals
                0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0,
                // Top face normals
                0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0,
                // Bottom face normals
                0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0,
                // Right face normals
                1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0,
                // Left face normals
                -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0
            ];

            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(cubeNormals), gl.STATIC_DRAW);
            cubeNormalBuffer.itemSize = 3;
            cubeNormalBuffer.numberOfItems = 24;

            cubeVertexIndexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);

            const cubeVertexIndices = [
                0, 1, 2, 0, 2, 3,    // Front face
                4, 6, 5, 4, 7, 6,    // Back face
                8, 9, 10, 8, 10, 11,  // Top face
                12, 14, 13, 12, 15, 14, // Bottom face
                16, 17, 18, 16, 18, 19, // Right face
                20, 22, 21, 20, 23, 22  // Left face
            ];

            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cubeVertexIndices), gl.STATIC_DRAW);
            cubeVertexIndexBuffer.itemSize = 1;
            cubeVertexIndexBuffer.numberOfItems = 36;
        }

        function setupCylinderBuffers() {
            cylinderVertexPositionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, cylinderVertexPositionBuffer);

            let radius = 0.1;
            let height = 1.5;
            let numSegments = 36;
            let cylinderVertices = [];
            let cylinderNormals = [];
            let angleStep = (2 * Math.PI) / numSegments;

            // Generate vertices and normals for the sides of the cylinder
            for (let i = 0; i <= numSegments; i++) {
                let angle = i * angleStep;
                let x = Math.cos(angle) * radius;
                let z = Math.sin(angle) * radius;

                // Bottom circle
                cylinderVertices.push(x, -height / 2, z);
                cylinderNormals.push(x, 0, z); // Normal points outward

                // Top circle
                cylinderVertices.push(x, height / 2, z);
                cylinderNormals.push(x, 0, z); // Normal points outward
            }

            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(cylinderVertices), gl.STATIC_DRAW);
            cylinderVertexPositionBuffer.itemSize = 3;
            cylinderVertexPositionBuffer.numberOfItems = (numSegments + 1) * 2;

            // Generate normals buffer
            cylinderNormalBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, cylinderNormalBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(cylinderNormals), gl.STATIC_DRAW);
            cylinderNormalBuffer.itemSize = 3;
            cylinderNormalBuffer.numberOfItems = (numSegments + 1) * 2;

            // Generate indices for the sides
            cylinderIndexPositionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cylinderIndexPositionBuffer);
            let cylinderIndices = [];

            for (let i = 0; i < numSegments; i++) {
                let p1 = i * 2;
                let p2 = p1 + 1;
                let p3 = (i + 1) * 2;
                let p4 = p3 + 1;

                cylinderIndices.push(p1, p2, p3); // Triangle 1
                cylinderIndices.push(p3, p2, p4); // Triangle 2
            }

            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cylinderIndices), gl.STATIC_DRAW);
            cylinderIndexPositionBuffer.itemSize = 3;
            cylinderIndexPositionBuffer.numberOfItems = cylinderIndices.length;
        }

        function setupPanelBuffers() {
            panelVertexPositionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, panelVertexPositionBuffer);


            const depth = 0.2;

            let panelVertexPosition = [
                // Front face
                2.0, 8.0, depth, -2.0, 8.0, depth, -2.0, -8.0, depth, 2.0, -8.0, depth,
                // Back face
                2.0, 8.0, -depth, -2.0, 8.0, -depth, -2.0, -8.0, -depth, 2.0, -8.0, -depth,
                // Top face
                2.0, 8.0, -depth, 2.0, 8.0, depth, -2.0, 8.0, depth, -2.0, 8.0, -depth,
                // Bottom face
                2.0, -8.0, -depth, 2.0, -8.0, depth, -2.0, -8.0, depth, -2.0, -8.0, -depth,
                // Right face
                2.0, 8.0, -depth, 2.0, -8.0, -depth, 2.0, -8.0, depth, 2.0, 8.0, depth,
                // Left face
                -2.0, 8.0, -depth, -2.0, -8.0, -depth, -2.0, -8.0, depth, -2.0, 8.0, depth
            ];

            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(panelVertexPosition), gl.STATIC_DRAW);
            panelVertexPositionBuffer.itemSize = 3;
            panelVertexPositionBuffer.numberOfItems = 24;

            panelNormalBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, panelNormalBuffer);

            let panelNormals = [
                // Front face
                0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0,
                // Back face
                0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0,
                // Top face
                0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0,
                // Bottom face
                0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0,
                // Right face
                1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0,
                // Left face
                -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0
            ];

            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(panelNormals), gl.STATIC_DRAW);
            panelNormalBuffer.itemSize = 3;
            panelNormalBuffer.numberOfItems = 24;

            panelIndexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, panelIndexBuffer);

            const panelIndices = [
                0, 1, 2, 0, 2, 3,   // Front face
                4, 6, 5, 4, 7, 6,   // Back face
                8, 9, 10, 8, 10, 11, // Top face
                12, 14, 13, 12, 15, 14, // Bottom face
                16, 17, 18, 16, 18, 19, // Right face
                20, 22, 21, 20, 23, 22  // Left face
            ];

            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(panelIndices), gl.STATIC_DRAW);
            panelIndexBuffer.itemSize = 1;
            panelIndexBuffer.numberOfItems = 36;

            panelTextureCoordBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, panelTextureCoordBuffer);

            let panelTextureCoords = [
                // Front face
                1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0,
                // Back face
                1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0,
                // Top face
                1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0,
                // Bottom face
                1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0,
                // Right face
                1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0,
                // Left face
                1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0
            ];

            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(panelTextureCoords), gl.STATIC_DRAW);
            panelTextureCoordBuffer.itemSize = 2;
            panelTextureCoordBuffer.numberOfItems = 24;
        }

        function setupDishBuffers() {
            dishVertexPositionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, dishVertexPositionBuffer);

            let radius = 2;
            let numRings = 20;
            let numSegments = 36;
            let curvature = 0.5;
            let dishVertices = [];
            let angleStep = (2 * Math.PI) / numSegments;

            for (let ring = 0; ring <= numRings; ring++) {
                let r = (ring / numRings) * radius;
                let z = -curvature * (1 - (ring / numRings)) ** 2;

                for (let segment = 0; segment <= numSegments; segment++) {
                    let angle = segment * angleStep;
                    let x = r * Math.cos(angle);
                    let y = r * Math.sin(angle);

                    dishVertices.push(x, y, z);
                }
            }

            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(dishVertices), gl.STATIC_DRAW);
            dishVertexPositionBuffer.itemSize = 3;
            dishVertexPositionBuffer.numberOfItems = (numRings + 1) * (numSegments + 1);

            dishIndexPositionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, dishIndexPositionBuffer);

            let dishIndices = [];

            for (let ring = 0; ring < numRings; ring++) {
                for (let segment = 0; segment < numSegments; segment++) {
                    let p1 = ring * (numSegments + 1) + segment;
                    let p2 = p1 + numSegments + 1;
                    let p3 = p1 + 1;
                    let p4 = p2 + 1;

                    dishIndices.push(p1, p2, p3);
                    dishIndices.push(p3, p2, p4);
                }
            }

            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(dishIndices), gl.STATIC_DRAW);
            dishIndexPositionBuffer.itemSize = 1;
            dishIndexPositionBuffer.numberOfItems = dishIndices.length;
        }

        function setupBuffers() {
            setupSphereBuffers(30);
            setupCubeBuffers();
            setupCylinderBuffers(0.1);
            setupCylinderBuffers(0.2);
            setupPanelBuffers();
            setupDishBuffers();
        }

        function uploadModelViewMatrixToShader() {
            gl.uniformMatrix4fv(shaderProgram.uniformMVMatrix, false, modelViewMatrix);

            let normalMatrix = mat3.create();
            mat4.toInverseMat3(modelViewMatrix, normalMatrix);
            mat3.transpose(normalMatrix, normalMatrix);

            gl.uniformMatrix3fv(shaderProgram.uNMatrix, false, normalMatrix);
        }

        function uploadProjectionMatrixToShader() {
            gl.uniformMatrix4fv(shaderProgram.uniformProjMatrix, false, projectionMatrix);
        }

        function calculateNormalMatrix() {
            let normalMatrix = mat3.create();
            mat4.toInverseMat3(modelViewMatrix, normalMatrix);
            mat3.transpose(normalMatrix, normalMatrix);
            return normalMatrix;
        }

        let solarPanelTexture;
        let earthTexture;

        function setupTextures() {
            solarPanelTexture = gl.createTexture();
            solarPanelImage = new Image();
            solarPanelImage.onload = function () {
                console.log("solar panel texture loaded!!!!!!!");
                gl.bindTexture(gl.TEXTURE_2D, solarPanelTexture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, solarPanelImage);

                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

                gl.bindTexture(gl.TEXTURE_2D, null);
            };
            solarPanelImage.src = "Solar panel.jpg";

            earthTexture = gl.createTexture();
            earthTexture.image = new Image();
            earthTexture.image.onload = function () {
                console.log("earth texture loaded!1");
                handleTextureLoaded(earthTexture);
            }
            earthTexture.image.src = "earth.jpg";

        }

        function handleTextureLoaded(texture) {
            gl.bindTexture(gl.TEXTURE_2D, texture);

            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true); // Flip the texture Y-axis

            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.image);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
            gl.generateMipmap(gl.TEXTURE_2D);
            gl.bindTexture(gl.TEXTURE_2D, null);
        }

        // DRAW FUNCTIONS////////////////////////

        function drawSphere() {
            gl.useProgram(shaderProgram);

            gl.bindBuffer(gl.ARRAY_BUFFER, sphereVertexPositionBuffer);
            gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);

            gl.bindBuffer(gl.ARRAY_BUFFER, sphereNormalBuffer);
            gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(shaderProgram.vertexNormalAttribute);

            gl.bindBuffer(gl.ARRAY_BUFFER, sphereTextureCoordBuffer);
            gl.vertexAttribPointer(shaderProgram.vertexTextureCoordAttribute, 2, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(shaderProgram.vertexTextureCoordAttribute);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, earthTexture);
            gl.uniform1i(shaderProgram.samplerUniform, 0);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, sphereIndexPositionBuffer);
            gl.drawElements(gl.TRIANGLES, sphereIndexPositionBuffer.numberOfItems, gl.UNSIGNED_SHORT, 0);
        }

        function drawCube() {
            gl.useProgram(goldenShaderProgram);

            gl.uniformMatrix4fv(goldenShaderProgram.uMVMatrix, false, modelViewMatrix);
            gl.uniformMatrix4fv(goldenShaderProgram.uPMatrix, false, projectionMatrix);

            let normalMatrix = mat3.create();
            mat4.toInverseMat3(modelViewMatrix, normalMatrix);
            mat3.transpose(normalMatrix, normalMatrix);
            gl.uniformMatrix3fv(goldenShaderProgram.uNMatrix, false, normalMatrix);

            let lightDirection = [-5.0, -5.0, -5.0];
            gl.uniform3fv(goldenShaderProgram.uLightDirection, lightDirection);
            gl.uniform3fv(goldenShaderProgram.uLightColor, [1.0, 1.0, 1.0]);

            gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
            gl.vertexAttribPointer(
                goldenShaderProgram.vertexPositionAttribute,
                cubeVertexPositionBuffer.itemSize,
                gl.FLOAT, false, 0, 0
            );
            gl.enableVertexAttribArray(goldenShaderProgram.vertexPositionAttribute);

            gl.bindBuffer(gl.ARRAY_BUFFER, cubeNormalBuffer);
            gl.vertexAttribPointer(
                goldenShaderProgram.vertexNormalAttribute,
                3, gl.FLOAT, false, 0, 0
            );
            gl.enableVertexAttribArray(goldenShaderProgram.vertexNormalAttribute);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);

            gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numberOfItems, gl.UNSIGNED_SHORT, 0);

            gl.useProgram(shaderProgram);
        }

        function drawCylinder(r, g, b, a) {

            gl.vertexAttrib4f(shaderProgram.vertexColorAttribute, r, g, b, a);

            gl.bindBuffer(gl.ARRAY_BUFFER, cylinderVertexPositionBuffer);
            gl.vertexAttribPointer(
                shaderProgram.vertexPositionAttribute,
                cylinderVertexPositionBuffer.itemSize,
                gl.FLOAT, false, 0, 0
            );
            gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);

            gl.bindBuffer(gl.ARRAY_BUFFER, cylinderNormalBuffer);
            gl.vertexAttribPointer(
                shaderProgram.vertexNormalAttribute,
                cylinderNormalBuffer.itemSize,
                gl.FLOAT, false, 0, 0
            );
            gl.enableVertexAttribArray(shaderProgram.vertexNormalAttribute);

            uploadModelViewMatrixToShader();
            uploadProjectionMatrixToShader();

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cylinderIndexPositionBuffer);
            gl.drawElements(gl.TRIANGLES, cylinderIndexPositionBuffer.numberOfItems, gl.UNSIGNED_SHORT, 0);
        }

        function drawPanel() {
            gl.useProgram(shaderProgram);

            gl.bindBuffer(gl.ARRAY_BUFFER, panelVertexPositionBuffer);
            gl.vertexAttribPointer(
                shaderProgram.vertexPositionAttribute,
                panelVertexPositionBuffer.itemSize,
                gl.FLOAT, false, 0, 0
            );
            gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);

            gl.bindBuffer(gl.ARRAY_BUFFER, panelNormalBuffer);
            gl.vertexAttribPointer(
                shaderProgram.vertexNormalAttribute,
                panelNormalBuffer.itemSize,
                gl.FLOAT, false, 0, 0
            );
            gl.enableVertexAttribArray(shaderProgram.vertexNormalAttribute);

            gl.bindBuffer(gl.ARRAY_BUFFER, panelTextureCoordBuffer);
            gl.vertexAttribPointer(
                shaderProgram.vertexTextureCoordAttribute,
                panelTextureCoordBuffer.itemSize,
                gl.FLOAT, false, 0, 0
            );
            gl.enableVertexAttribArray(shaderProgram.vertexTextureCoordAttribute);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, solarPanelTexture);
            gl.uniform1i(shaderProgram.samplerUniform, 0);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, panelIndexBuffer);
            gl.drawElements(gl.TRIANGLES, panelIndexBuffer.numberOfItems, gl.UNSIGNED_SHORT, 0);
        }

        function drawDish(r, g, b, a) {
            gl.vertexAttrib4f(shaderProgram.vertexColorAttribute, r, g, b, a);

            gl.bindBuffer(gl.ARRAY_BUFFER, dishVertexPositionBuffer);
            gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, dishVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, dishIndexPositionBuffer);
            gl.drawElements(gl.TRIANGLES, dishIndexPositionBuffer.numberOfItems, gl.UNSIGNED_SHORT, 0);
        }

        function drawSatellite(orbitRadius) {
            // combines cube, cylinder, dish, and panel to create a satellite

            satelliteOrbitRadius = orbitRadius;
            pushModelViewMatrix();
            const satelliteX = satelliteOrbitRadius * Math.cos(satelliteOrbitAngle);
            const satelliteZ = satelliteOrbitRadius * Math.sin(satelliteOrbitAngle);
            mat4.translate(modelViewMatrix, [satelliteX, 0, satelliteZ]);
            mat4.rotateY(modelViewMatrix, -satelliteOrbitAngle);
            
            //cube
            uploadModelViewMatrixToShader();
            drawCube(1.0, 1.0, 0.0, 1.0);

            //left cylinder
            pushModelViewMatrix();
            mat4.translate(modelViewMatrix, [0, 0, -3.5]);
            mat4.rotateZ(modelViewMatrix, Math.PI / 2);
            mat4.rotateX(modelViewMatrix, Math.PI / 2);
            uploadModelViewMatrixToShader();
            drawCylinder(0.0, 1.0, 0.0, 1.0);
            //left panel
            pushModelViewMatrix();
            mat4.translate(modelViewMatrix, [0, -8.8, 0]);
            mat4.rotateY(modelViewMatrix, Math.PI / 2);
            uploadModelViewMatrixToShader();
            drawPanel();

            popModelViewMatrix();
            popModelViewMatrix();
            //right cylinder
            pushModelViewMatrix();
            mat4.translate(modelViewMatrix, [0, 0, 3.5]);
            mat4.rotateZ(modelViewMatrix, Math.PI / 2);
            mat4.rotateX(modelViewMatrix, Math.PI / 2);
            uploadModelViewMatrixToShader();
            drawCylinder(0.0, 0.0, 1.0, 1.0);
            //right panel
            pushModelViewMatrix();
            mat4.translate(modelViewMatrix, [0, 8.8, 0]);
            mat4.rotateY(modelViewMatrix, Math.PI / 2);
            uploadModelViewMatrixToShader();
            drawPanel();

            popModelViewMatrix();
            popModelViewMatrix();

            //front cylinder
            pushModelViewMatrix();
            mat4.translate(modelViewMatrix, [-3.5, 0, 0]);
            mat4.rotateZ(modelViewMatrix, Math.PI / 2);
            uploadModelViewMatrixToShader();
            drawCylinder(0.0, 1.0, 1.0, 1.0);
            //front dish
            pushModelViewMatrix();
            mat4.translate(modelViewMatrix, [0, 1.2, 0]);
            mat4.rotateX(modelViewMatrix, Math.PI / -2);
            uploadModelViewMatrixToShader();
            drawDish(1.0, 1.0, 1.0, 1.0);

            popModelViewMatrix();
            popModelViewMatrix();

        }

        function drawEarth() {
            // uses sphere and manipulates the y rotation to create the spinning effect
            let angle = elapsedTime * 0.0003;
            pushModelViewMatrix();
            mat4.rotateY(modelViewMatrix, angle);
            mat4.rotateX(modelViewMatrix, 60); // tilt the earth like in real life
            uploadModelViewMatrixToShader();
            drawSphere();
            popModelViewMatrix();
        }

        function drawScene(zoomValue, rotateX, rotateY, moveX, moveY) {
            gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            mat4.perspective(60, gl.viewportWidth / gl.viewportHeight, 0.1, 500.0, projectionMatrix);
            mat4.identity(modelViewMatrix);
            mat4.lookAt([rotateX, rotateY, zoomValue], [moveX, moveY, 0], [0, 1, 0], modelViewMatrix);
            setUpLighting();
            uploadProjectionMatrixToShader();
            uploadModelViewMatrixToShader();

            drawEarth();
            drawSatellite(satelliteOrbitRadius);
        }
        // USER CONTROLSSSSSS //////////////////////////
        function handleUserControls() {
            //controls for moving the satellite
            document.addEventListener("keydown", function (event) {
                if (event.key === "ArrowRight") {
                    satelliteOrbitRadius += 1;
                    console.log("moving further from earth");
                } else if (event.key === "ArrowLeft") {
                    if (satelliteOrbitRadius > 40) {
                        satelliteOrbitRadius -= 1;
                        console.log("moving closer to earth");
                    } else {
                        console.log("TOO CLOSE BRUH!!!!!!!!!!!!!!!!!!!");
                    }
                }
            });
            
            //satellite speed controls
            document.addEventListener("keydown", function (event) {
                if (event.key === "ArrowUp") {
                    satelliteOrbitSpeed += 0.001;
                    console.log("speedup!!!!!!!!!1");
                } else if (event.key === "ArrowDown") {
                    if (satelliteOrbitSpeed > 0.001) {
                        satelliteOrbitSpeed -= 0.001;
                        console.log("slowdown!!");
                    } else {
                        console.log("slow down limit reached, do u want to crash to the earth? :>");
                    }
                }
            });
            // controls for zooming in and out
            document.addEventListener("wheel", function (event) {
                if (event.deltaY > 0) {
                    if (zoomValue < 200) {
                        zoomValue += 5;
                        console.log("user scrolling up", zoomValue);
                    } else {
                        console.log("maximum zoom out reached");
                    }
                } else if (event.deltaY < 0) {
                    if (zoomValue > 40) {
                        zoomValue -= 5;
                        console.log("user scrolling down", zoomValue);
                    } else {
                        console.log("maximum zoom in reached");
                    }
                }
            });

            // controls for rotating the camera
            //kind of buggy so introduced limits to prevent the camera from going too far
            // ¯\_(ツ)_/¯
            document.addEventListener("mousedown", function (event) {
                // if shift key is pressed, user can drag left or right to rotate the camera
                if (event.shiftKey) {
                    let startX = event.clientX;
                    let lastX = startX;
                    document.addEventListener("mousemove", onMouseMove);

                    function onMouseMove(event) {
                        if (event.clientX < lastX) {
                            moveX -= 5;
                            console.log("user holding down shift and dragging left <");
                        } else if (event.clientX > lastX) {
                            moveX += 5;
                            console.log("user holding down shift and dragging right >");
                        }
                        lastX = event.clientX;
                    }
                }
                // if alt key is pressed, user can drag up or down to zoom in or out
                else if (event.altKey) {
                    let startY = event.clientY;
                    let lastY = startY;
                    document.addEventListener("mousemove", onMouseMove);

                    function onMouseMove(event) {
                        if (event.clientY < lastY) {
                            moveY += 5;
                            console.log("user alt dragging up ^");
                        } else if (event.clientY > lastY) {
                            moveY -= 5;
                            console.log("user alt dragging down v");
                        }
                        lastY = event.clientY;
                    }
                } else {
                    // if neither shift nor alt key is pressed, user can drag up down l and r to rotate the camera
                    let startY = event.clientY;
                    let lastY = startY;
                    let startX = event.clientX;
                    let lastX = startX;

                    document.addEventListener("mousemove", onMouseMove);

                    function onMouseMove(event) {
                        if (event.clientY < lastY) {
                            if (rotateY > -200) {
                                rotateY -= 5;
                                console.log("user JUST dragging down", rotateY);
                            } else {
                                console.log("TOO LOW BRUH!!!!!!!!!!!!!!!!!!!");
                            }
                        } else if (event.clientY > lastY) {
                            if (rotateY < 200) {
                                rotateY += 5;
                                console.log("user JUST dragging up", rotateY);
                            } else {
                                console.log("TOO HIGH BRUH!!!!!!!!!!!!!!!!!!!");
                            }
                            
                        }
                        lastY = event.clientY;

                        if (event.clientX < lastX) {
                            if (rotateX < 200) {
                                rotateX += 5;
                                console.log("user JUST dragging right", rotateX);
                            } else {
                                console.log("TOO RIGHT BRUH!!!!!!!!!!!!!!!!!!!");
                            }
                            
                        } else if (event.clientX > lastX) {
                            if (rotateX > -200) {
                                rotateX -= 5;
                                console.log("user JUST dragging left", rotateX);
                            } else {
                                console.log("TOO LEFT BRUH!!!!!!!!!!!!!!!!!!!");
                            }
                        }
                        lastX = event.clientX;
                    }
                }
                // remove the event listener after the user releases the mouse
                document.addEventListener("mouseup", function () {
                    document.removeEventListener("mousemove", onMouseMove);
                }, { once: true });
            });
        }

        function animate() {
            // Update the elapsed time and the orbit angle
            let timeNow = new Date().getTime();
            if (lastTime != 0) {
                let elapsed = timeNow - lastTime;
                elapsedTime += elapsed;
                satelliteOrbitAngle += elapsed * satelliteOrbitSpeed; 
            }
            lastTime = timeNow;
        }

        function tick() {
            requestAnimationFrame(tick); // better than setInterval and makes it nice for high refresh rate monitors
            drawScene(zoomValue, rotateX, rotateY, moveX, moveY);
            animate();
        }

        function startup() {
            canvas = document.getElementById("myGLCanvas");
            gl = createGLContext(canvas);
            setupBuffers();
            setupShaders();
            setupTextures();
            setupGoldenShader();
            handleUserControls();
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.enable(gl.DEPTH_TEST);
            //animate();
            tick();
        }
    </script>
</head>

<body onload="startup();">
    <canvas id="myGLCanvas" width="1920" height="1000"></canvas>
</body>

</html>