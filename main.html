<!DOCTYPE HTML>
<html lang="en">
<head>
    <title> Sphere </title>
    <meta charset="utf-8">
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100%;
        }
        canvas {
            display: block;
        }
    </style>
    <script src="glMatrix.js"></script>
    <script src="webgl-debug.js"></script>
    <script id="shader-vs" type="x-shader/x-vertex">
        attribute vec3 aVertexPosition;
        attribute vec2 aTextureCoord;
        uniform mat4 uMVMatrix;
        uniform mat4 uPMatrix;
        varying vec2 vTextureCoord;
        void main() {
            gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
            vTextureCoord = aTextureCoord;
        }
    </script>
    <script id="shader-fs" type="x-shader/x-fragment">
        precision mediump float;
        varying vec2 vTextureCoord;
        uniform sampler2D uSampler;
        void main() {
            gl_FragColor = texture2D(uSampler, vTextureCoord);
        }
    </script>
    <script type="text/javascript">
        var gl;
        var canvas;
        var shaderProgram;
        var sphereVertexPositionBuffer;
        var sphereIndexPositionBuffer;
        var sphereVertexTextureCoordBuffer;
        var earthTexture;
        var cubeTexture;
        var modelViewMatrix;
        var projectionMatrix;
        var modelViewMatrixStack;

        function createGLContext(canvas) {
            var names = ["webgl", "experimental-webgl"];
            var context = null;
            for (var i = 0; i < names.length; i++) {
                try {
                    context = canvas.getContext(names[i]);
                } catch (e) {}
                if (context) {
                    break;
                }
            }
            if (context) {
                context.viewportWidth = canvas.width;
                context.viewportHeight = canvas.height;
            } else {
                alert("Failed to create WebGL context!");
            }
            return context;
        }

        function loadShaderFromDOM(id) {
            var shaderScript = document.getElementById(id);
            if (!shaderScript) {
                return null;
            }
            var shaderSource = "";
            var currentChild = shaderScript.firstChild;
            while (currentChild) {
                if (currentChild.nodeType == 3) { // 3 corresponds to TEXT_NODE
                    shaderSource += currentChild.textContent;
                }
                currentChild = currentChild.nextSibling;
            }
            var shader;
            if (shaderScript.type == "x-shader/x-fragment") {
                shader = gl.createShader(gl.FRAGMENT_SHADER);
            } else if (shaderScript.type == "x-shader/x-vertex") {
                shader = gl.createShader(gl.VERTEX_SHADER);
            } else {
                return null;
            }
            gl.shaderSource(shader, shaderSource);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                alert(gl.getShaderInfoLog(shader));
                return null;
            }
            return shader;
        }

        function setupShaders() {
            var vertexShader = loadShaderFromDOM("shader-vs");
            var fragmentShader = loadShaderFromDOM("shader-fs");
            shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);
            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                alert("Failed to setup shaders");
            }
            gl.useProgram(shaderProgram);
            shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
            shaderProgram.textureCoordAttribute = gl.getAttribLocation(shaderProgram, "aTextureCoord");
            shaderProgram.uniformMVMatrix = gl.getUniformLocation(shaderProgram, "uMVMatrix");
            shaderProgram.uniformProjMatrix = gl.getUniformLocation(shaderProgram, "uPMatrix");
            shaderProgram.samplerUniform = gl.getUniformLocation(shaderProgram, "uSampler");
            modelViewMatrix = mat4.create();
            projectionMatrix = mat4.create();
            modelViewMatrixStack = [];
            gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);
            gl.enableVertexAttribArray(shaderProgram.textureCoordAttribute);
        }

        function pushModelViewMatrix() {
            var copyToPush = mat4.create(modelViewMatrix);
            modelViewMatrixStack.push(copyToPush);
        }

        function popModelViewMatrix() {
            if (modelViewMatrixStack.length == 0) {
                throw "Error popModelViewMatrix() - Stack was empty ";
            }
            modelViewMatrix = modelViewMatrixStack.pop();
        }

        function setupEarthBuffers() {
            sphereVertexPositionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, sphereVertexPositionBuffer);
            var sphereVertexPosition = [];
            var sphereTextureCoord = [];
            var r = 3; // radius
            var m = 15;
            var n = 15;
            for (var i = 0; i <= m; i++) {
                for (var j = 0; j <= n; j++) {
                    var theta = i * Math.PI / m;
                    var phi = j * 2 * Math.PI / n;
                    var x = r * Math.sin(theta) * Math.cos(phi);
                    var y = r * Math.cos(theta);
                    var z = r * Math.sin(theta) * Math.sin(phi);
                    sphereVertexPosition.push(x);
                    sphereVertexPosition.push(y);
                    sphereVertexPosition.push(z);
                    var u = j / n;
                    var v = i / m;
                    sphereTextureCoord.push(u);
                    sphereTextureCoord.push(v);
                }
            }
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(sphereVertexPosition), gl.STATIC_DRAW);
            sphereVertexPositionBuffer.itemSize = 3;
            sphereVertexPositionBuffer.numberOfItems = (m + 1) * (n + 1);

            sphereVertexTextureCoordBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, sphereVertexTextureCoordBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(sphereTextureCoord), gl.STATIC_DRAW);
            sphereVertexTextureCoordBuffer.itemSize = 2;
            sphereVertexTextureCoordBuffer.numberOfItems = (m + 1) * (n + 1);

            sphereIndexPositionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, sphereIndexPositionBuffer);
            var sphereIndexPosition = [];
            for (var i = 0; i < m; i++) {
                for (var j = 0; j < n; j++) {
                    var v1 = i * (n + 1) + j;
                    var v2 = v1 + n + 1;
                    var v3 = v1 + 1;
                    var v4 = v2 + 1;
                    sphereIndexPosition.push(v1);
                    sphereIndexPosition.push(v2);
                    sphereIndexPosition.push(v3);
                    sphereIndexPosition.push(v3);
                    sphereIndexPosition.push(v2);
                    sphereIndexPosition.push(v4);
                }
            }
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(sphereIndexPosition), gl.STATIC_DRAW);
            sphereIndexPositionBuffer.itemSize = 3;
            sphereIndexPositionBuffer.numberOfItems = m * n * 2 * 3;
        }

        function setupCubeBuffers() {
            cubeVertexPositionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
            var cubeVertexPosition = [
                2.0, 2.0, 2.0, //v0
                -2.0, 2.0, 2.0, //v1
                -2.0, -2.0, 2.0, //v2
                2.0, -2.0, 2.0, //v3
                2.0, 2.0, -2.0, //v4
                -2.0, 2.0, -2.0, //v5
                -2.0, -2.0, -2.0, //v6
                2.0, -2.0, -2.0, //v7
            ];
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(cubeVertexPosition), gl.STATIC_DRAW);
            cubeVertexPositionBuffer.itemSize = 3;
            cubeVertexPositionBuffer.numberOfItems = 8;
            cubeVertexIndexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
            var cubeVertexIndices = [
                0, 1, 2, 0, 2, 3, // Front face
                4, 6, 5, 4, 7, 6, // Back face
                1, 5, 6, 1, 6, 2, //left
                0, 3, 7, 0, 7, 4, //right
                0, 5, 1, 0, 4, 5, //top
                3, 2, 6, 3, 6, 7 //bottom
            ];
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cubeVertexIndices), gl.STATIC_DRAW);
            cubeVertexIndexBuffer.itemSize = 1;
            cubeVertexIndexBuffer.numberOfItems = 36;
        }

        function setupBuffers() {
            setupEarthBuffers();
            setupCubeBuffers();
        }

        function uploadModelViewMatrixToShader() {
            gl.uniformMatrix4fv(shaderProgram.uniformMVMatrix, false, modelViewMatrix);
        }

        function uploadProjectionMatrixToShader() {
            gl.uniformMatrix4fv(shaderProgram.uniformProjMatrix, false, projectionMatrix);
        }

        function drawEarth() {
            gl.bindBuffer(gl.ARRAY_BUFFER, sphereVertexPositionBuffer);
            gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, sphereVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, sphereVertexTextureCoordBuffer);
            gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, sphereVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, earthTexture);
            gl.uniform1i(shaderProgram.samplerUniform, 0);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, sphereIndexPositionBuffer);
            gl.drawElements(gl.TRIANGLES, sphereIndexPositionBuffer.numberOfItems, gl.UNSIGNED_SHORT, 0);
        }

        function drawCube() {
            gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
            gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, cubeVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
            gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numberOfItems, gl.UNSIGNED_SHORT, 0);
        }

        function drawCylinder() {
            gl.bindBuffer(gl.ARRAY_BUFFER, cylinderVertexPositionBuffer);
            gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, cylinderVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, cylinderVertexTextureCoordBuffer);
            gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, cylinderVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, cylinderTexture);
            gl.uniform1i(shaderProgram.samplerUniform, 0);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cylinderIndexPositionBuffer);
            gl.drawElements(gl.TRIANGLES, cylinderIndexPositionBuffer.numberOfItems, gl.UNSIGNED_SHORT, 0);
        }

        function draw() {
            gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            mat4.perspective(60, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, projectionMatrix);
            mat4.identity(modelViewMatrix);
            mat4.lookAt([0, 5, -10], [0, 0, 0], [0, 1, 0], modelViewMatrix);
            uploadModelViewMatrixToShader();
            uploadProjectionMatrixToShader();
            drawEarth();
            drawCube();
        }

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewportWidth = canvas.width;
            gl.viewportHeight = canvas.height;
            draw();
        }

        function handleTextureLoaded(image, texture) {
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
            gl.generateMipmap(gl.TEXTURE_2D);
            gl.bindTexture(gl.TEXTURE_2D, null);
        }

        function initTextures() {
            earthTexture = gl.createTexture();
            var earthImage = new Image();
            earthImage.onload = function() {
                handleTextureLoaded(earthImage, earthTexture);
            }
            earthImage.src = "earth.jpg";
        }

        function startup() {
            canvas = document.getElementById("myGLCanvas");
            gl = WebGLDebugUtils.makeDebugContext(createGLContext(canvas));
            setupShaders();
            setupBuffers();
            initTextures();
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.enable(gl.DEPTH_TEST);
            
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();
            
        }
    </script>
</head>
<body onload="startup()">
    <canvas id="myGLCanvas" width="800" height="600"></canvas>
</body>
</html>